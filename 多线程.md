# 多线程

## 1. Java 绘图

![未命名绘图](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261410187.png)

像素（pixel）--- 密度单位

分辨率：800 * 600 （一行由 800 个点组成，共 600 行）

### 1.1 画图相关类

![image-20221126143222883](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261433681.png)

### 1.2 绘图原理

#### 1.2.1 Component 类

Component类提供了2个和绘图相关最重要的方法：

1）paint(Graphics g)绘制组件的外观

2）repaint() 刷新组件的外观

当组件第一次在屏幕显示的时候，程序会自动地调用 paint() 方法来绘制组

当以下情况 paint() 将会被调用：

1）窗口最小化，再最大化

2）窗口的大小发生变化

3）repaint方法被调用

【底层有监听机制】

#### 1.2.2 Graphics 类

你可以理解成就是画笔，为我们提供了各种绘制图形的方法

| 画图         | 方法                                           |
| ------------ | ---------------------------------------------- |
| 直线         | drawLine(int x1, int y1, int x2, int y2)       |
| 矩形边框     | drwaRect(int x, int y, int width, int height)  |
| 椭圆边框     | drawOval(int x , int y, int width, int height) |
| 填充矩形     | fillRect(int x, int y, int width, int height)  |
| 填充椭圆     | fillOval(int x, int y, int width, int height)  |
| 画图片       | drawImage(Image img, int x, int y,...)         |
| 画字符串     | drawString(String str, int x, int y)           |
| 设置画笔字体 | setFont(Font font)                             |
| 设置画笔颜色 | setColor(Color c)                              |

nbsp：（Non-breaking Space）：超文本标记语言中表示空格

应用：&nbsp;

rect：矩形

```java
package draw;

import javax.swing.*;
import java.awt.*;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/5/23 - 05 - 23 - 23:39
 * @Description: draw
 * @version: 1.0
 * 演示如何在面板上画出圆形
 */
public class DrawCircle extends JFrame{ //  JFrame 相当于画框（窗口），面板要嵌入到画框中 ---> 画框.add(画板)

    //  定义一个面板
    private MyPanel myPanel = null;

    public static void main(String[] args) {
        new DrawCircle();
    }

    //  设置一个构造器
    public DrawCircle() {
        //  初始化面板
        myPanel = new MyPanel();
        //  现在将面板放入到画框（窗口）里面去
        this.add(myPanel);
        //  设置窗口的大小
        this.setSize(400, 300);
        //  当点击窗口的小 ×，程序就完全退出
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);  //  可以显示

    }
}

//  1. 先定义一个 MyPanel，继承JPanel 类， 画图形，就在面板上画
class MyPanel extends JPanel {


    //  说明：
    //  1. MyPanel 对象就是一个画板
    //  2. Graphics g 把 g 理解成一支画笔
    //  3. Graphics 提供了喝多绘图的方法

    @Override
    public void paint(Graphics g) { //  绘图方法
        super.paint(g); // 调用父类方法，完成初始化
        System.out.println("paint 方法被调用了！！！");
        //  画出一个圆形
        g.drawOval(10, 10, 100, 100);

        //  演示绘制不同的图形...

        //  nbsp 在 html中是空格的意思

        //  画直线 drawLine(int x1, int y1, int x2, int y2)
        g.drawLine(10, 10, 100, 100);

        //  画矩形边框 drawRect(intNBSPx, intNBSPy, intNBSPwidth, intNBSPheight)
        g.drawRect(10, 10, 100, 100);

        //  画填充矩形 fillRect(intNBSPx, intNBSPy, intNBSPwidth, intNBSPheight)
        //  可以有颜色
        //  设置画笔的颜色
        g.setColor(Color.pink);
        g.fillRect(10,  10, 100, 100);

        //  填充椭圆  fillOval(intNBSPx, intNBSPy, intNBSPwidth, intNBSPheight)
        g.setColor(Color.red);
        g.fillOval(10, 10, 100, 100);

        //  画图片 drawImage(ImageNBSPimg, intNBSPx, intNBSPy,...)
        //  1）获取图片资源，/wind.png 表示在该项目的根目录去获取 wind.png 图片资源
        Image image = Toolkit.getDefaultToolkit().getImage(MyPanel.class.getResource("/wind.png"));
        g.drawImage(image, 10, 10, 1143, 819, this);

        //  画字符串 drawString(StringNBSPstr, intNBSPx, intNBSPy)  ---> 写字
        //  给画笔设置颜色和字体
        g.setColor(Color.red);
        g.setFont(new Font("隶书", Font.BOLD, 50));
        g.drawString("北京欢迎你", 100, 100);    //  （x, y）字体的左下角

    }
}
```

### 1.3 关闭窗口，也让程序结束

```java
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
```

### 1.4 小球移动案例 【事件监听】

窗口 JFrame 对象可以监听键盘事件，即：可以监听到面板发生的键盘事件

```java
this.addKeyListener(KeyListener l)
```

![image-20221126151840852](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261518908.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261518497.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261519718.png)

```java
//  KeyListener 是监听器，可以监听键盘事件
class MyPanel extends JPanel implements KeyListener {

    //  为了让小球可以移动，把他的左上角的坐标（x, y）设置成变量
    int x = 10;
    int y = 10;
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillOval(x, y, 20, 20);   //  默认黑色
    }

    //  有字符输出时，该方法就会触发
    @Override
    public void keyTyped(KeyEvent e) {

    }
    //  当某个按键按下时，该方法就会触发
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println((char)e.getKeyCode() + "被按下");

        //  根据用户按下的不同键，来处理小球的移动（上下左右）
        //  在java 中，会给每一个键，分配一个值（int）
        if (e.getKeyCode() == e.VK_DOWN){   //  e.VK_DOWN 就是向下的箭头对应的code(ASCII码)
            y++;
        }else if (e.getKeyCode() == e.VK_UP){
            y--;
        }else if (e.getKeyCode() == e.VK_LEFT){
            x--;
        }else if (e.getKeyCode() == e.VK_RIGHT){
            x++;
        }

        //  让面板重绘：
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
}

```

```java
public class BallMove extends JFrame {
    MyPanel mp = null;

    public static void main(String[] args) {
        BallMove ballMove = new BallMove();
    }

    public BallMove(){
        mp = new MyPanel();
        this.add(mp);
        this.setSize(400, 300);

        //  窗口 JFrame 对象可以监听键盘事件，即：可以监听到面板发生的键盘事件
        this.addKeyListener(mp);    //  接口引用 可以指向实现了这个接口的对象
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);

    }
}

```

### 1.5 事件处理机制

事件处理机制深入理解：

1）前面我们提到几个重要的概念：事件源，事件，事件监听器，我们下面来全面地介绍它们

2）<font color="yellow">事件源</font>：事件源是一个产生事件的对象，比如：按钮，窗口等

3）<font color="yellow">事件</font>：事件就是承载事件源状态改变时的对象，比如：当键盘事件，鼠标事件，窗口事件等等，会生成一个事件对象，该对象保存着当前事件很多信息，比如：KeyEvent 对象有包含被按下键的 Code值。java.awt.event 包 和 java.swing.event包中定义了各种事件类型

#### 1.5.1 事件类型

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261527346.png)

#### 1.5.2 事件监听器接口

1）当事件源产生一个事件，可以传送给事件监听者处理

2）<font color="yellow">事件监听者 </font>实际上就是一个类，该类<font color="red"> 实现了某个事件监听器接口</font>

比如：前面我们案例中的MyPanel  就是一个类，它实现了KeyListener 接口，它就可以作为一个事件监听者，对接受到的事件进行处理

3）事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件，一个类可以实现多个监听接口

4）这些接口在 java.awt.event包和javax.swing.event包中定义。列出常用的事件监听器接口，查看 jdk文档

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261530118.png)

## 2. 绘制坦克

### 2.1 Battle_City 01 

![image-20221126150426220](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261504267.png)

```java
//	坦克大战绘图区域
public class MyPanel extends JPanel {

    //  定义我的坦克
    My_tank my_tank = null;

    public MyPanel(){
        my_tank = new My_tank(100, 100);    //  初始化自己的坦克
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);    //  填充矩形，默认黑色

        //  画出坦克 -- 封装方法
        drawTank(my_tank.getX(), my_tank.getY(), g, 0, 0);
        drawTank(my_tank.getX() + 60, my_tank.getY(), g, 0, 1);

    }

    /**
     *
     * @param x 坦克的左上角 x 坐标
     * @param y 坦克的左上角 y 坐标
     * @param g 画笔
     * @param direction 坦克方向（上下左右）
     * @param type  坦克类型
     */
    //  编写方法，画出坦克
    public void drawTank(int x, int y, Graphics g, int direction, int type) {

        //  根据不同类型坦克，设置不同颜色
        switch (type){
            case 0: //  我们的坦克
                g.setColor(Color.cyan);
                break;
            case 1: //  敌人的坦克
                g.setColor(Color.yellow);
                break;
        }

        //  根据坦克方向，来绘制坦克
        switch (direction){
            case 0: //  表示向上
                g.fill3DRect(x, y, 10, 60, false);  //  画出坦克左边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);  //  画出坦克中间的矩形
                g.fill3DRect(x + 30, y, 10, 60, false);  //  画出坦克右边的轮子
                g.fillOval(x + 10, y + 20, 20, 20);  //  画出坦克中间的圆形锅盖
                g.drawLine(x + 20, y + 30, x + 20, y);  //  画出坦克的炮筒
                break;
        }
    }
}
```

```java
    public class TankGame01 extends JFrame {
        //  定义MyPanel
        MyPanel mp = null;
        public static void main(String[] args) {
            TankGame01 tankGame01 = new TankGame01();
        }
        public TankGame01(){
            mp = new MyPanel();
            this.add(mp);   //  把面板（就是游戏的绘图区域）
            this.setSize(1000, 750);
            this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            this.setVisible(true);
        }
    }

```

### 2.2 Battle_CIty 02

- 因为敌人坦克，是在 MyPanel 上，所以我们的代码在 MyPanel
- 因为敌人坦克，后面 有自己特殊的属性和方法，可以单开一个 EnemyTank
- 敌人坦克数量多，可以放入到集合 Vector，因为考虑多线程问题

![image-20221126150901473](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261509528.png)

```java
//  为了监听 键盘事件，实现KeyListener接口
public class MyPanel extends JPanel implements KeyListener {

    //  定义我的坦克
    My_tank my_tank = null;

    //  定义敌人坦克，放入到 Vector中
    Vector<EnemyTank> enemyTanks = new Vector<>();

    public MyPanel(){
        my_tank = new My_tank(100, 100);    //  初始化自己的坦克
        my_tank.setSpeed(7);

        int enemyTankSize = 3;
        //  初始化敌人的坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = new EnemyTank((100 * (i + 1)), 0);
            enemyTank.setDirection(2);
            enemyTanks.add(enemyTank);
        }

    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);    //  填充矩形，默认黑色

        //  画出坦克 -- 封装方法
        drawTank(my_tank.getX(), my_tank.getY(), g, my_tank.getDirection(), 1);

        //  画出敌人的坦克，遍历 Vector
        for (int i = 0; i < enemyTanks.size(); i++) {   //  因为坦克有可能被销毁的，所以要用 enemyTanks.size()
            //  取出坦克
            EnemyTank enemyTank = enemyTanks.get(i);
            drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirection(), 0);
        }
    }

    /**
     *
     * @param x 坦克的左上角 x 坐标
     * @param y 坦克的左上角 y 坐标
     * @param g 画笔
     * @param direction 坦克方向（上下左右）
     * @param type  坦克类型
     */
    //  编写方法，画出坦克
    public void drawTank(int x, int y, Graphics g, int direction, int type) {

        //  根据不同类型坦克，设置不同颜色
        switch (type){
            case 0: //  敌人的坦克
                g.setColor(Color.cyan);
                break;
            case 1: //  我的坦克
                g.setColor(Color.yellow);
                break;
        }

        //  根据坦克方向，来绘制坦克
        //  direct 表示方向（0, 1, 2, 3）
        switch (direction){
            case 0: //  表示向上
                g.fill3DRect(x, y, 10, 60, false);  //  画出坦克左边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);  //  画出坦克中间的矩形
                g.fill3DRect(x + 30, y, 10, 60, false);  //  画出坦克右边的轮子
                g.fillOval(x + 10, y + 20, 20, 20);  //  画出坦克中间的圆形锅盖
                g.drawLine(x + 20, y + 30, x + 20, y);  //  画出坦克的炮筒
                break;
            case 1: //  表示向右
                g.fill3DRect(x, y, 60, 10, false);  //  画出坦克左边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);  //  画出坦克中间的矩形
                g.fill3DRect(x, y + 30, 60, 10, false);  //  画出坦克右边的轮子
                g.fillOval(x + 20, y + 10, 20, 20);  //  画出坦克中间的圆形锅盖
                g.drawLine(x + 30, y + 20, x + 60, y + 20);  //  画出坦克的炮筒
                break;
            case 2: //  表示向下
                g.fill3DRect(x, y, 10, 60, false);  //  画出坦克左边的轮子
                g.fill3DRect(x + 10, y + 10, 20, 40, false);  //  画出坦克中间的矩形
                g.fill3DRect(x + 30, y, 10, 60, false);  //  画出坦克右边的轮子
                g.fillOval(x + 10, y + 20, 20, 20);  //  画出坦克中间的圆形锅盖
                g.drawLine(x + 20, y + 30, x + 20, y + 60);  //  画出坦克的炮筒
                break;
            case 3: //  表示向左
                g.fill3DRect(x, y, 60, 10, false);  //  画出坦克左边的轮子
                g.fill3DRect(x + 10, y + 10, 40, 20, false);  //  画出坦克中间的矩形
                g.fill3DRect(x, y + 30, 60, 10, false);  //  画出坦克右边的轮子
                g.fillOval(x + 20, y + 10, 20, 20);  //  画出坦克中间的圆形锅盖
                g.drawLine(x + 30, y + 20, x, y + 20);  //  画出坦克的炮筒
                break;
        }
    }


    @Override
    public void keyTyped(KeyEvent e) {

    }

    //  处理wdsa 键按下的情况
    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W){   //  按下 W 键
            //  改变坦克的方向
            my_tank.setDirection(0);
            //  修改坦克的坐标 y -= 1
            my_tank.moveUp();
        }else if(e.getKeyCode() == KeyEvent.VK_D){  //  按下 D 键
            my_tank.setDirection(1);
            my_tank.moveRight();
        }else if (e.getKeyCode() == KeyEvent.VK_S){ //  按下 S 键
            my_tank.setDirection(2);
            my_tank.moveDown();
        }else if (e.getKeyCode() == KeyEvent.VK_A){
            my_tank.setDirection(3);
            my_tank.moveLeft();
        }

        //  让面板重绘
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
}
```

```java
public class TankGame02 extends JFrame {
    //  定义MyPanel
    MyPanel mp = null;
    public static void main(String[] args) {
        TankGame02 tankGame02 = new TankGame02();
    }
    public TankGame02(){
        mp = new MyPanel();
        this.add(mp);   //  把面板（就是游戏的绘图区域）
        this.setSize(1000, 750);
        this.addKeyListener(mp);    //  让 JFrame 监听 mp 的键盘事件
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
    }
}
```



## 3. 线程

程序（program）

### 3.1 进程

【程序是一个静态的概念，而进程是一个动态的东西】

- 进程是运行中的程序
  - 比如我们使用 QQ，就启动了一个进程，操作系统就会为该进程分配内存空间
  - 当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间
- 进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身产生、存在和消亡的过程

### 3.2 线程

1）线程是由进程创建的，是进程的一个实体

2）1个进程可以拥有多个线程



每一个敌人的坦克都是一个线程

每一颗子弹都有自己的生命周期

- 打到墙上 
- 打到敌人的坦克，
- 同时敌人的坦克爆炸

### 3.3 并发并行

并发：同一个时刻，多个任务交替执行，造成一种 “***\*貌似同时\****” 的错觉，简单地说：***\*单核\**** CPU实现的多任务就是并发。

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261554343.png)

并行：同一个时刻，多个任务同时执行。***\*多核\****CPU可以实现并行。

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261554338.png)

### 3.4 查看 CPU 个数

```java
public class CpuNum {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime(); //  底层是一个单例模式
        //  获取电脑的 cpu 数量 / 核心数
        int cpuNums = runtime.availableProcessors();
        System.out.println("CPU个数为：" + cpuNums);
    }
}
```



### 3.5 线程核心 start0() 方法

```java
cat.start();	//	启动线程，最终执行 cat的 run 方法
```

问：为为什么不直接调用 run() 方法 === cat.run(); ???

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261630699.png)

因为这样就相当于主线程直接调用 run() 方法 ===> 这个时候打出的线程名称就是 main。【也就是没有真正地开线程】

此时 run() 方法就是一个普通的方法，它必须要把这个 run() 方法执行完毕后，才会执行下面的代码，并不是真正的多线程 ===> 相当于
串行化“（阻塞在这里）。

start ---> start0（native）JVM 机来调用。C / C ++

实际上，可以理解成，在 start0 里面，它用多线程机制来调用 run() 方法

start() 方法调用 start0() 方法后，该线程不一定会立即执行，只是将线程变成了可运行状态，具体什么时候执行，取决于 CPU，由 CPU统一调度

线程讲到最后，一定会涉及到操作系统

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261631561.png)



```java
public synchronized void start() {
    /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}
```





### 3.6  线程的基本使用

![image-20221126160050243](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261600362.png)

#### 3.6.1 继承 Thread 类

```java
package Thread_use;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/6/14 - 06 - 14 - 0:33
 * @Description: Thread_use
 * @version: 1.0
 */
public class Thread01 {
    public static void main(String[] args) {

        //  创建 Cat对象，
        new Cat().start();  //  启动线程

    }
}


//  老韩说明
//  1）当一个类继承了 Thread类，该类就可以当成线程使用
//  2）我们会重写 run() 方法，写上自己的业务代码
//  3）run Thread 类实现了 Runnable 接口的 run 方法
/*
@Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
 */

class Cat extends Thread {
    int times = 0;
    @Override
    public void run() { //  重写 run() 方法，写上自己的业务逻辑
        while (true){
            System.out.println("喵喵，我是小猫咪" + (++times));
            //  让线程休眠1秒
            try {
                Thread.sleep(1000); //  单位是 ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (times == 80){
                break;  //  当 times 到80，退出 while 循环，这时线程也就退出...
            }
        }
    }
}
```

使用 JConsole 监控线程 情况，并画出示意图：

在终端中打开 JConcole 

**【后面学的时候，可能遇到线程已经死掉了，但是程序还没退出】**

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261604903.png)

```java
package Thread_use;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/6/14 - 06 - 14 - 0:33
 * @Description: Thread_use
 * @version: 1.0
 */
public class Thread01 {
    public static void main(String[] args) throws InterruptedException {

        //  创建 Cat对象，可以当做线程使用
        new Cat().start();  //  启动线程

        //  说明：当main 线程启动一个子线程 Thread-0，主线程不会阻塞，会继续执行
        //  这时，主线程和子线程是交替执行。。。
        System.out.println("主线程继续执行" + Thread.currentThread().getName());   //  主线程的名称就叫 main
        for (int i = 0; i < 60; i++) {
            System.out.println("主线程 i=" + i);
            //  让主线程休眠
            Thread.sleep(1000);
        }

    }
}


//  老韩说明
//  1）当一个类继承了 Thread类，该类就可以当成线程使用
//  2）我们会重写 run() 方法，写上自己的业务代码
//  3）run Thread 类实现了 Runnable 接口的 run 方法
/*
@Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
 */

class Cat extends Thread {
    int times = 0;
    @Override
    public void run() { //  重写 run() 方法，写上自己的业务逻辑
        while (true){
            System.out.println("喵喵，我是小猫咪" + (++times) + "线程名称=" + Thread.currentThread().getName());
            //  让线程休眠1秒
            try {
                Thread.sleep(1000); //  单位是 ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (times == 80){
                break;  //  当 times 到80，退出 while 循环，这时线程也就退出...
            }
        }
    }
}
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261610307.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261610320.png)

Thread-0-结束，会造成整个进程结束。24412可以简单地理解成进程号

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261611578.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261611459.png)

主线程输出60次之后，它就挂了

而子线程是要输出80次的，所以子线程还在继续工作 ---> 造成这个***\*进程还活着\****

而等到80次执行完毕，它也挂了

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261611975.png)

 进程也退出来了之后，整个界面它就卡了，就相当于没有响应了



总结：在多线程变成里面，不是你 的主方法结束了，进程就结束了，不一定。

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261613581.png)

这样的话，就相当于开了2个子线程

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261614696.png)

同理，我们紫色的 Thread-0 也可以再开子线程 （子线程中再开子线程）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261614416.png)

#### 3.6.2 实现 Runnable 接口 【设计模式：代理模式】

- java是***\*单继承\****的，在某些情况下，一个类可能已经继承了某个父类，这时在用继承 Thread类方法来创建线程显然已经不可能了。
- java设计者们提供了另外一个方式创建线程，就是通过实现 Runnable 接口来创建线程 



核心点：只有 Thread 类的 start0() 方法才可以开启线程【start --->  start0 ---> run（动态绑定）】

代理模式

代理 Proxy

我自己没有 Start 方法，我让你代替我完成【静态代理模式】

```java
//  线程代理类，模拟了一个极简的 Thread 类
class ThreadProxy implements Runnable{    //  你可以把 Proxy类当做 ThreadProxy (买票代理。跑腿的)

    private Runnable target = null; //  属性，类型是 Runnable

    @Override
    public void run() {
        if (target != null) {
            target.run();	//	动态绑定
        }
    }

    public ThreadProxy(Runnable target) {
        this.target = target;
    }

    public void start(){
        start0();   //  这个方法是真正实现多线程的方法
    }

    public void start0(){
        run();
    }
}
```

### 3.7  继承 Thread 	VS 	实现 Runnable 区别

1. 从java的设计来看，通过继承 Thread 或者 实现 Runnable接口来创建线程本质上没有区别

   从jdk帮助文档我们可以看到 Thread类本身就实现了 Runnable接口 start() ---> start0()

2. 实现Runnable接口方式更加适合多个线程***\*共享一个资源\****的情况，并且避免了单继承的限制。建议使用 Runnable() 接口

### 3.8 多线程售票模拟

模拟有三个窗口售票，分别使用继承 Thread 类 和 实现 Runnable接口的方式，并分析有什么问题？

​    窗口有100张票

#### 3.8.1 继承 Thread 类

```java
package ticket;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/7/2 - 07 - 02 - 13:52
 * @Description: ticket
 * @version: 1.0
 * 使用多线程，模拟三个窗口同时售票 100 张
 */
public class SellTicket {
    public static void main(String[] args) {

        //  模拟3个窗口，所以要创建3个这样的对象
        SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();

        sellTicket01.start();   //  启动售票线程
        sellTicket02.start();   //  启动售票线程
        sellTicket03.start();   //  启动售票线程

    }
}

//  使用 Thread 方式

class SellTicket01 extends Thread {

    private static int TicketNum = 100; //  让多个线程共享 num

    @Override
    public void run() {
        while (true) {
            if (TicketNum <= 0) {
                System.out.println("售票结束......");
                break;
            }

            //   休眠 50ms，模拟
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口 " + Thread.currentThread().getName() + " 售出一张票"
                               + " 剩余票数=" + (--TicketNum));

        }
    }
}
```

瞬间3个线程，会出现超卖的现象

#### 3.8.2 实现 Runnable() 接口

```java
package ticket;
 
/**
 * @Author: Ronnie LEE
 * @Date: 2022/7/2 - 07 - 02 - 13:52
 * @Description: ticket
 * @version: 1.0
 * 使用多线程，模拟三个窗口同时售票 100 张
 */
public class SellTicket {
    public static void main(String[] args) {
 
        //  模拟3个窗口，所以要创建3个这样的对象
        System.out.println("=====使用实现接口方式来售票====");
 
        Thread thread1 = new Thread(new SellTicket02());
        Thread thread2 = new Thread(new SellTicket02());
        Thread thread3 = new Thread(new SellTicket02());
 
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
 

class SellTicket02 implements Runnable {
 
    private static int TicketNum = 100; //  让多个线程共享 num
 
    @Override
    public void run() {
        while (true) {
            if (TicketNum <= 0) {
                System.out.println("售票结束......");
                break;
            }
 
            //   休眠 50ms，模拟
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
 
            System.out.println("窗口 " + Thread.currentThread().getName() + " 售出一张票"
                    + " 剩余票数=" + (--TicketNum));
 
        }
    }
}
 
```

现象还是一样的，因为不管怎么样，还是会有3个线程

 分析有什么解决方式

现实中很多这种应用案例，比如说***\*秒杀\****

### 3.9 线程中断

1）当线程完成任务后，会自动退出

2）通过***\*使用变量\****来控制 run() 方法退出的方式停止线程，即：通知方式

例子：启动一个线程 t，要求在 main 线程中 去停止线程t，请编程实现

```java
package ticket;

import java.awt.*;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/7/2 - 07 - 02 - 14:29
 * @Description: ticket
 * @version: 1.0
 */
public class ThreadExit_ {
    public static void main(String[] args) throws InterruptedException {

        T t = new T();
        t.start();

        //  如果希望 main线程去控制 T 线程的终止，必须可以修改 loop
        //  让 t1 退出 run() 方法，从而终止 t1 线程 ---> 通知方式

        //  让主线程休眠10 秒，再通知 t1 线程退出
        System.out.println("主线程休眠10s...");
        Thread.sleep(10 * 1000);
        t.setLoop(false);

    }
}

class T extends Thread {

    private int count = 0;
    //  设置一个控制变量
    private boolean loop = true;

    @Override
    public void run() {

        while (loop){

            try {
                Thread.sleep(50);   //  让线程休眠 50 ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("A Thread 运行中......" + (++count));

        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

 以此类推，如果我们希望 t1 通知 t2 退出

我们在 t1 中set t2 中的变量，通知 t2 退出就可以了 

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261713155.png)

### 3.9 线程常用方法

#### 3.9.1 第一组

```java
	1）setName：//  设置线程名称，使之与参数 name 相同

    2）getName   //  返回该线程的名称

    3）start        //  使该线程开始执行；Java虚拟机底层调用线程的 start0 方法

    4）run         //   调用线程对象的 run 方法

    5）setPriority  // 更改线程的优先级

    6）getPriority  // 获取线程的优先级

    7）sleep  //  在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）

    8）interrupt  // 中断线程 【不是终止】
```

#### 3.9.2 第二组

1）yield：线程的礼让，让出 CPU，让其他线程执行，但礼让时间不确定，所以也不一定礼让成功

2）join：线程的插队

插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务

案例：创建一个子线程，每隔1s 输出 hello,输出 20次,主线程每隔1秒，输出hi,输出 20次.要求: 两个线程同时执行，当主线程输出 5次后，就让子线程运行完毕，主线程再继续。

```java
public class Homework01 {
    public static void main(String[] args) throws InterruptedException {
        int count = 0;
        T1 t1 = new T1();
        t1.start();

        for (int i = 0; i < 20; i++) {
            Thread.sleep(1000);
            System.out.println("hi的次数：" + (++count));
            if (count == 5) {
                System.out.println("主线程（小弟）让 子线程（老大） 先吃");
                t1.join();  //  这里相当于让 t2 线程先执行完毕
                System.out.println("老大吃完了，小弟你接着吃吧...");
            }
        }
    }
}

class T1 extends Thread {
    private int count1 = 0;
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("hello次数 :" + (++count1));
        }
    }
}

```







### 3.10 注意事项和细节

1）start 底层会创建新的线程，调用 run，run 就是一个简单的方法调用，不会启动新线程

2）线程优先级的范围 [1, 10] (默认是 5)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261715078.png)

3）interrupt（吵醒），中断线程，但没有真正的结束线程。所以一般用于中断<font color=blue>正在休眠的线程</font>

相当于被唤醒了

4）sleep：线程的***\*静态\****方法，使 ***\*当前线程\**** 休眠

```java
package method;

import java.util.SortedMap;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/7/2 - 07 - 02 - 16:08
 * @Description: method
 * @version: 1.0
 */
public class ThreadMethod01 {
    public static void main(String[] args) throws InterruptedException {

        ThreadDemo1 threadDemo1 = new ThreadDemo1();
        threadDemo1.setName("LQ");
        threadDemo1.setPriority(Thread.MIN_PRIORITY);
        threadDemo1.start();    //  启动子线程

        //  主线程打印 5个 hi，然后我就中断 子线程的休眠
        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000);
            System.out.println("hi " + i);
        }

        System.out.println(threadDemo1.getName() + "  线程的优先级：" + threadDemo1.getPriority());

        threadDemo1.interrupt();    //  当执行到这里，就会中断 ThreadDemo1 线程的休眠


    }
}

class ThreadDemo1 extends Thread {  //  自定义的线程类
    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 100; i++) {
                //  Thread.currentThread().getName() 获取当前线程的名称
                System.out.println(Thread.currentThread().getName() + "  吃包子~~~" + i);
            }

            System.out.println(Thread.currentThread().getName() + " 休眠中~~~");
            try {
                Thread.sleep(20000); //  休息5s
            } catch (InterruptedException e) {
                //  当该线程执行到一个 interrupt 方法时，就会 catch 一个 异常时，可以加入自己的业务代码
                System.out.println(Thread.currentThread().getName() + "被 interrupt了");
            }
        }
    }
}
```

### 3.11 用户线程和守护线程（Daemon）

1）用户线程：也叫工作线程，当线程的任务执行完或通知方式（）结束

2）守护线程：一般是为了工作线程服务的，当所有的用户线程结束，守护线程自动结束

3）常见的守护线程：垃圾回收机制

例子：【main退出时，即使 t1 是无限循环的，它也能够自动退出】--- ***\*守护\****线程

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211261728527.png)

```java
public class ThreadMethod03 {
    public static void main(String[] args) throws InterruptedException {

        MyDaemonThread myDaemonThread = new MyDaemonThread();
        //  如果我们希望当 main 线程结束后，子线程自动结束
        //  只需将子线程设置为 守护线程即可
        myDaemonThread.setDaemon(true);
        myDaemonThread.start();

        for (int i = 0; i < 10; i++) {
            System.out.println("唱跳 Rap 篮球");
            Thread.sleep(1000);
        }

    }
}

class MyDaemonThread extends Thread {
    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);   //  休眠1000 ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("鸡你太美！！！~~~");

        }
    }
}
```

以后这个守护线程还是有用的，比如说你将来在做多线程的时候，你希望有一个线程来

1）监控其他的线程

2）获取其他线程的信息

利于我们对多线程的管理 --- 比如垃圾回收机制【经典的守护线程】

Daemon

只要你还有线程在工作，那么垃圾回收机制就会为你服务，守护着你

## 4. 线程的 7 大状态

![image-20221126211536542](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211262115665.png)

### 4.1 线程的生命周期

JDK中用 ***\*Thread.State\**** <font color="red">枚举表示了线程的几种状态

```java
/**
     * A thread state.  A thread can be in one of the following states:
     * <ul>
     * <li>{@link #NEW}<br>
     *     A thread that has not yet started is in this state.
     *     </li>
     * <li>{@link #RUNNABLE}<br>
     *     A thread executing in the Java virtual machine is in this state.
     *     </li>
     * <li>{@link #BLOCKED}<br>
     *     A thread that is blocked waiting for a monitor lock
     *     is in this state.
     *     </li>
     * <li>{@link #WAITING}<br>
     *     A thread that is waiting indefinitely for another thread to
     *     perform a particular action is in this state.
     *     </li>
     * <li>{@link #TIMED_WAITING}<br>
     *     A thread that is waiting for another thread to perform an action
     *     for up to a specified waiting time is in this state.
     *     </li>
     * <li>{@link #TERMINATED}<br>
     *     A thread that has exited is in this state.
     *     </li>
     * </ul>
     *
     * <p>
     * A thread can be in only one state at a given point in time.
     * These states are virtual machine states which do not reflect
     * any operating system thread states.
     *
     * @since   1.5
     * @see #getState
     */
public enum State {
    /**
         * Thread state for a thread which has not yet started.
         */
    NEW,

    /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
    RUNNABLE,

    /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
    BLOCKED,

    /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called {@code Object.wait()}
         * on an object is waiting for another thread to call
         * {@code Object.notify()} or {@code Object.notifyAll()} on
         * that object. A thread that has called {@code Thread.join()}
         * is waiting for a specified thread to terminate.
         */
    WAITING,

    /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
    TIMED_WAITING,

    /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
    TERMINATED;
}
```

| 线程状态                             | 含义                                        |
| ------------------------------------ | ------------------------------------------- |
| 1. NEW                               | 至今尚未启动的线程                          |
| 2. RUNNABLE【a、Ready   b、Running】 | 正在虚拟机中执行的线程                      |
| 3. BLOCKED                           | 受阻塞并等待某个监视器锁的线程              |
| 4. WAITING                           | 正在等待另一个线程执行特定动作              |
| 5. TIMEWAITING                       | 正在等待另一个线程执行动作达到指定等待时间. |
| 6. TERMINATED                        | 已退出的线程处于这种状态                    |

【在给定时间点上，一个线程只能处于一种状态。这些状态是虚拟机状态，它们并没有反映所有操作提供线程状态】

Runnable：代表可以运行了，但是是否真正运行，要取决于<font color="red">线程调度器</font>，这个不是你程序可以控制的，是否<font color="blue">操作系统</font>控制的（内核态）

- Ready（就绪态）
- Running（真正的持有，占有我们的 CPU）

```java
public class ThreadState_ {
    public static void main(String[] args) throws InterruptedException {
        T t = new T();
        System.out.println(t.getName() + " 状态 " + t.getState());

        t.start();
        while (Thread.State.TERMINATED != t.getState()) {
            System.out.println(t.getName() + " 状态 " + t.getState());
            Thread.sleep(500); //  让主线程休眠（每 0.5s 查询一下线程状态）
        }
        System.out.println(t.getName() + " 状态 " + t.getState());
    }
}

class T extends Thread{
    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 10; i++) {
                System.out.println("hi " + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            break;
        }
    }
}
```





### 4.2 线程同步机制

1. 在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证 <font color="red">数据在任何时刻，最多有一个线程访问</font>，以保证数据的完整性。
2. 也可以这样理解：线程同步，即当有一个线程在对内存进行操作时，其它线程都不可以对这个内存地址进行操作，直到该线程完成操作，其它线程才能对该内存地址进行操作。



#### 4.2.1  同步具体方法 --- Synchronized

1. 同步代码块

   ```java
   synchronized (对象) {	//	得到对象的锁，才能操作同步代码
       //	需要被同步代码
   }
   ```

2. synchronized 放在方法声明中，表示整个方法为 同步方法

   ```java
   public synchronized void m (String name) {
       //	需要被同步的代码
   }
   ```

   如何理解?

![image_0.11184706364375119](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211271458437.gif)



#### 4.2.2 使用 synchronized 解决售票问题

```java
public class SellTicket_sync {
    public static void main(String[] args) {
        //  模拟3个窗口，所以要创建3个这样的对象
        System.out.println("=====使用实现接口方式来售票====");

        SellTicket03 sellTicket03 = new SellTicket03();

        Thread thread1 = new Thread(sellTicket03);
        Thread thread2 = new Thread(sellTicket03);
        Thread thread3 = new Thread(sellTicket03);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}


//  实现接口方式，使用 synchronized 实现线程同步
class SellTicket03 implements Runnable {

    private int TicketNum = 1000; //  让多个线程共享 num
    private boolean loop = true;    //  控制 run 方法的变量

    Object object = new Object();

    public synchronized void sell() {   //  同步方法，在同一时刻，只能有一个线程来执行 sell() 方法
        if (TicketNum <= 0) {
            System.out.println("售票结束......");
            loop = false;
            return;
        }
        //   休眠 50ms，模拟
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("窗口 " + Thread.currentThread().getName() + " 售出一张票"
                           + " 剩余票数=" + (--TicketNum));
    }

    @Override
    public void run() {
        while (loop) {
            sell(); //  sell 方法是一个同步方法，
        }
    }
}

```

【思考：不能继承 Thread 来操作，因为 synchronized 操作的是一个对象，如果是继承 Thread 的话，创建的是 3 个对象，肯定是自己跑自己的】



#### 4.2.3 分析同步原理

注意：锁是在 对象上的，不是在代码块上的 ===> 所以叫做对象锁

synchronized：一种非公平锁

![image-20221127153430260](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211271534486.png)

#### 4.2.4 互斥锁

1. Java 语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性
2. <font color="red">每个对象</font> 都对应于一个可称为 “互斥锁” 的 <font color="red">标记</font>【底层（本质一个数字）】，这个标记用来保证在任一时刻，只能有一个线程访问该对象
3. 关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问
4. 同步的局限性：导致程序的执行效率要降低 【收费站：一杆一车】
5. 同步方法（非静态的）的锁可以是this，也可以是其他对象（要求线程操作的是同一个对象【继承 Runnable 接口来实现】）
6. 同步方法（静态的）的锁为当前类本身。（类.class）

```java
public class SellTicket_sync {
    public static void main(String[] args) {
        //  模拟3个窗口，所以要创建3个这样的对象
        System.out.println("=====使用实现接口方式来售票====");

        SellTicket03 sellTicket03 = new SellTicket03();	

        Thread thread1 = new Thread(sellTicket03);
        Thread thread2 = new Thread(sellTicket03);	//	动态绑定 【3个线程 start 后，都是操作的 sellTicket03.run()方法】
        Thread thread3 = new Thread(sellTicket03);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}


//  实现接口方式，使用 synchronized 实现线程同步
class SellTicket03 implements Runnable {

    private int TicketNum = 100; //  让多个线程共享 num
    private boolean loop = true;    //  控制 run 方法的变量

    Object object = new Object();	//	object 是一个成员
    //	老韩说明：
    //	1. public synchronized void sell() {} 就是一个同步方法
    //	2. 这时锁 在 this 对象
    //	3. 也可以在代码块上写 synchronized，同步代码块

    public void sell() { 
        synchronized (object) {
            if (TicketNum <= 0) {
                System.out.println("售票结束......");
                loop = false;
                return;
            }
            //   休眠 50ms，模拟
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("窗口 " + Thread.currentThread().getName() + " 售出一张票"
                               + " 剩余票数=" + (--TicketNum));
        }
    }
      @Override
    public void run() {
        while (loop) {
            sell(); //  sell 方法是一个同步方法，
        }
    }
}
```

注意：如果同步方法是静态的，锁为当前类本身

```java
//	老韩解读
//	静态方法的锁 是加载 SellTicket03.class
public static synchronized void m(){}

//	如果在静态方法中，实现一个同步代码块，锁显示声明为：类名.class
public static void m2(){
    synchronized(SellTicket03.class){
        System.out.println("m2");
    }
}
//	本质：静态方法中，不能直接使用 this
```

#### 4.2.5 注意事项和细节

1. 同步方法如果没有使用 static 修饰：默认锁对象为 this
2. 如果方法使用 static 修饰，默认锁对象：当前类.class
3. 实现的落地步骤：
   - 需要先分析上锁的代码
   - 选择***\*同步代码块\**** 【效率高】或同步方法
   - 要求多个线程的锁对象为同一个即可！！！

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211271623776.png)

#### 4.2.6 线程死锁

多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程时一定要避免死锁的发生

应用案例：

- 妈妈：你先完成作业，才让你玩手机
- 小明：你先让我玩手机，我才完成作业.

```java
// 关键字 synchronized 来与对象的互斥锁联系。当某个对象用 synchronized 修饰时，表明该对象在任一时刻只能由一个线程访问
```



```java
package sync_;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/7/6 - 07 - 06 - 0:03
 * @Description: sync_
 * @version: 1.0
 * 模拟线程死锁
 */
public class DeadLock_ {
    public static void main(String[] args) {

        //  模拟死锁现象
        DeadLockDemo A = new DeadLockDemo(true);
        A.setName("A线程");
        DeadLockDemo B = new DeadLockDemo(false);
        B.setName("B线程");
        A.start();
        B.start();

    }
}

class DeadLockDemo extends Thread {
    static Object o1 = new Object();    //  保证多线程，共享一个对象，这里使用 static
    static Object o2 = new Object();
    boolean flag;

    public DeadLockDemo(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {

        //  下面业务逻辑的分析
        //  1）如果 flag 为 T，线程 A 就会先得到 / 持有 o1 对象锁，然后尝试去获取 o2 对象锁
        //  2）如果线程 A 得不到 o2 对象锁，就会 Blocked
        //  3）如果 flag 为 F, 线程 B 就会先得到 / 持有 o2 对象锁，然后尝试去获取 o1 对象锁
        //  4）如果线程 A 得不到 o2 对象锁，就会 Blocked
        if (flag) {
            synchronized (o1){  //  对象互斥锁，下面就是同步代码
                System.out.println(Thread.currentThread().getName() + " 进入1");
                synchronized (o2) { //  这里获得 li 对象的监视权
                    System.out.println(Thread.currentThread().getName() + " 进入2");
                }
            }
        } else {
            synchronized (o2){
                System.out.println(Thread.currentThread().getName() + " 进入3");
                synchronized (o1) { //  这里获得 li 对象的监视权
                    System.out.println(Thread.currentThread().getName() + " 进入4");
                }
            }

        }
    }
}

```

![image-20221127201410003](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211272014103.png)

#### 4.2.7 释放锁

##### 1. 释放锁

下面操作会释放锁

1. 当前线程的同步方法、同步代码块 <font color="red">执行结束</font>

   案例：上完厕所，完事出来

2. 当前线程在同步代码块、同步方法中遇到 ***\*break\****，***\*return\****

   案例：没有正常完事，经理叫他修改bug，不得已出来

3. 当前线程在同步代码块，同步方法中出现了未处理的 ***\*Error\****或***\*Exception\****，导致异常结束

   案例：没有正常的完事，发现忘带纸，不得已出来

4. 当前线程在同步代码块、同步方法中执行了线程对象的 ***\*wait()\****，当前线程暂停，并释放锁。

   案例：没有正常完事，觉得需要酝酿下，所以出来等会再进去

   

##### 2. 不释放锁

不会释放锁的情况

1. 线程执行同步代码块或同步方法时，程序调用 Thread.***\*sleep()\****时、Thread.***\*yield()\****方法暂停当钱线程的执行，不会释放锁

   案例：上厕所，太困了，在坑位上眯了一会

2. 线程执行同步代码块时，其他线程调用了该线程的 ***\*suspend()\**** 方法将该线程挂起，该线程不会释放锁

   提示：应避免使用suspend() 和 resume() 来控制线程，方法不再推荐使用



## 5. 课后作业

习题1：

- main方法中启动 2 个线程
- 在第一个线程循环打印 100 以内的整数
- 直到第二个线程从键盘读取了 "Q" 命令

![image-20221127212446444](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211272124553.png)

```java
//	核心思想【通知方式】
//	B线程 持有 A线程对象
```

```java
public class homework01 {
    public static void main(String[] args) {
        A a = new A();
        a.start();
        new B(a).start();

    }
}

class A extends Thread {
    boolean loop = true;
    @Override
    public void run() {
        while (loop){
            System.out.println((int) (100 * Math.random()));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}

class B extends Thread{
    A a = null;
    private Scanner scanner = new Scanner(System.in);
    @Override
    public void run() {
        while (true){
            System.out.println("请输入Q 停止)");
            String next = scanner.next();
            if ("Q".equals(next)){
                //  以通知的方式结束 A 线程
                a.setLoop(false);
                break;
            }
        }
    }

    public B(A a){  //  构造器中，传入 A 类对象
        this.a = a;
    }
}
```



习题2：

- 有2个用户分别从同一个卡上取钱（2个线程）
- 每次都取出1000，当余额不足时，就不能取款了
- 不能出现超取的现象 ===> 线程同步问题

![image-20221128005846929](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211280058041.png)

```java
public class homewok02 {
    public static void main(String[] args) {
        bank bank = new bank();
        Thread thread1 = new Thread(bank);
        thread1.setName("甲");
        Thread thread2 = new Thread(bank);
        thread2.setName("乙");
        thread1.start();
        thread2.start();
    }
}

class bank implements Runnable{
    private int money = 1000000;
    boolean loop = true;
    @Override
    public void run() {
        while (loop){
            getMoney();
        }
    }

    public void setCount(int money) {
        this.money = money;
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }

    public void getMoney(){
        synchronized (this){
            if (money < 1000){
                setLoop(false);
                return;
            }
            System.out.println(Thread.currentThread().getName() + "取走了 1000 元");
            setCount(money - 1000);
            System.out.println("还剩下" + money);
        }
    }
}

```











