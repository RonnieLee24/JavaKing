# 网络多线程

## 1. 相关命令

### 1.1 查看主机名

```java
 LAPTOP-JREQNCE8
```

### 1.2 查看端口占用情况

#### Linux

```bash
lsof -i:端口号
```

杀死进程 kill -9 进程号

```bash
-t (tcp) 仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化为数字
-l 仅列出在Listen(监听)的服务状态
-p 显示建立相关链接的程序名
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211280115244.png)

#### Windows

```bash
netstat -ano
netstat -ano|findstr 9999
```

杀死进程 taskkill -f /pid 51144

测试服务器 TCP 端口是否通

telnet IP 端口号



测试服务器 UDP端口是否通

[PsPing - Windows Sysinternals | Microsoft Docs](https://docs.microsoft.com/en-us/sysinternals/downloads/psping)

使用 psping 工具

nc工具（netcat）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211280118184.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211280119456.png)

[Structured Streaming with .NET for Apache Spark tutorial | Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/spark/tutorials/streaming)

[GitHub - int0x33/nc.exe: Netcat for windows 32/64 bit](https://github.com/int0x33/nc.exe/)

这些小东西，在 Github 中可以找到

![image-20221128111931178](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281119231.png)

[测试UDP端口是否打开 – 编织梦想的猫](http://www.884358.com/test-udp-port/)

```bash
nc -u ip 9999
输入
```

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/9/4 - 09 - 04 - 14:50
 * @Description: udp
 * @version: 1.0
 * 接收端A
 */
public class UDPReceiverA {
    public static void main(String[] args) throws IOException {

        //  1） 创建一个 DatagramSocket 对象，准备在9999 端口接收数据
        DatagramSocket socket = new DatagramSocket(9999);
        //  2） 构建一个 DatagramPacket 对象，准备接收数据
        //      在前面讲解 UDP 协议时，讲过一个数据包最大 64 K
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        //  3） 调用 接收方法，将通过网络传输的 DatagramPacket 对象
        //  填充到 packet对象
        //  提示：当有数据包发送到 本机的 9999 端口时，就会接收到数据
        //  如果没有数据包发送到本机的 9999 端口，就会阻塞等待
        System.out.println("接收端A 等待接收数据...");
        socket.receive(packet);

        //  4） 可以把 packet 进行拆包，取出数据，并显示
        int length = packet.getLength();    //  实际接收到的数据字节长度
        byte[] data = packet.getData();     //  接收到的数据
        String s = new String(data, 0, length);
        System.out.println(s);

        /*********************回复信息给B端********************************/
        //   将需要发送的数据，封装到 DatagramPacket 对象
        data = "好的，明天见".getBytes(); //  相当于数据更新了一下（要不直接复制过来，会有变量冲突）

        //  说明：封装的 DatagramPacket 对象 data 内容字节数组，data.length, 主机（IP），端口
        packet = new DatagramPacket(data, data.length, InetAddress.getByName("1.2.3.4"), 9999);
        socket.send(packet);

        //  5）关闭资源
        socket.close();
        System.out.println("A端退出...");
    }
}
```



## 2. 网络相关概念

### 2.1 网络通信

1）概念：2台设备之间通过网络实现数据传输

2）网络通信：将数据通过网络从一台设备传输到另一台设备

3）java.net 包下提供了一系列的类或接口，供程序员使用，完成网络通信

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281122085.png)

### 2.2 网络

1）概念：两台或多台设备通过一定物理设备连接起来构成网络

2）根据网络的覆盖范围不同，对网络进行分类：

a：***\*局\****域网：覆盖范围小，仅仅覆盖一个教室或一个机房

b：***\*域\****域网：覆盖范围较大，可以覆盖一个城市

c：***\*广\****域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表

### 2.3 IP地址

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281124953.png)

#### 2.3.1 ipv4 地址分类

$$
S_{n}=\frac{a_{1}(1 - q^{n})}{1-q}
$$

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281142264.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281142307.png)

前 8 位都为1 的时候，和为：255

- A类：干掉 高位 0，$$2^{^{8 - 1}} = 128$$ ，255 - 128 = 127
- B类：干掉 次高位 0，$$2^{^{8 - 2}} = 64$$ ，255 - 64 = 191
- C类：干掉 次次高位 0，$$2^{^{8 - 3}} = 32$$，255 - 32 = 223
- D类：干掉 次次次高位 0，$$2^{^{8 - 4}} = 16$$，255 - 16 = 239
- E类：干掉 次次次次高位 0，$$2^{^{8 - 5}} = 8$$，255 - 8 = 247

### 2.4 域名

将 IP 地址映射成域名，通过 HTTP协议映射

2个字节【16位】表示端口 $$2^{^{16}} - 1 = 65535$$
![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281157255.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281157728.png)

### 2.5 网络通信协议

数据的组织形式就是<font color="red">协议</font>

类似外卖一样，不能直接给你送过来，要经过处理才可以

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281159055.png)

- 通过 Date sendtime 获取发送时间
- 通过 String content 获取内容

数据进入协议栈时的封装过程：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281201420.png)

#### 2.5.1 协议

协议（TCP / IP）

Protocol / Internet Protocol 的缩写，中文译名为：传输控制协议 / 因特网互联协议，又叫做网络通讯协议，这个协议是 Internet最基本的协议，Internet 国际互联网络的基础，简答地说，就是由

- 网络层 IP 协议
- 传输层的 TCP 协议组成的

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281207347.png)

#### 2.5.2 TCP（传输控制协议）UDP（用户数据协议）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281210837.png)

#### 2.5.3 三次握手

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281214649.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281215980.gif)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281218718.png)

1.  C ---> S：带有 SYN 标志的数据包
2.  S ---> C：带有 SYN、ACK 标志的数据包
3.  C ---> S：带有 ACK 标志的数据包

#### 2.5.4 为什么需要 三次握手

三次握手的目的是建立<font color="red">可靠的通信信道</font>，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

最终目的是为了确认：从客户端和服务器的角度看都是正常的：

| 握手次数 | 客户端角度 | 服务器角度 |
| -------- | ---------- | ---------- |
| 1        | null       | A发        |
| 2        | B收、发    | null       |
| 3        | null       | A收、发    |

接收端（B）传回发送端(A)所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端【A ---> B】的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端【B ---> A】的通信。”

SYN 同步序列编号(Synchronize Sequence Numbers) 

TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

[浅谈 TCP 三次握手、四次挥手 | Yuuki的小站](https://hanblog.fun/2020/06/25/2020-6-25-tcp-3/)

#### 2.5.4 四次挥手

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281233938.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281233679.gif)

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。（A --- B断了）
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗*∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

**MSL（Maximum Segment Lifetime）**，

TCP允许不同的实现可以设置不同的MSL值

- 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
- 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

### 2.6 InetAdress

#### 2.6.1 相关方法

| 方法名         | 作用                              |
| -------------- | --------------------------------- |
| getLocalHost   | 获取本机 InetAddress 对象         |
| getByName      | 根据主机名 / 域名获取 ip 地址对象 |
| getHostName    | 获取 InetAddress 对象的主机名     |
| getHostAddress | 获取 InetAddress 对象的地址       |

坑爹的就是InetAddress.getLocalHost返回了一个错误的IP地址。为什么这个函数会返回一个错误的地址，因为这个函数的原理是通过 获取本机的hostname，然后对此hostname做解析，从而获取IP地址的。那么问题来了，如果在本机的/etc/hosts文件里对这个主机名 指向了一个错误的IP地址，那么InetAddress.getLocalHost就会返回这个错误的IP地址。当然如果你的hostname是到DNS 去解析的，碰巧DNS上的信息也是错的，也同样是悲惨结局。 

注意：getLocalHost的算法是愚蠢的，因为会被hosts文件和DNS误导，这2个都不是本机IP地址的权威获取处，应该去网卡本身配置信息获取

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281240134.png)

```java
package api_;

import java.net.InetAddress;
import java.net.UnknownHostException;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/8/27 - 08 - 27 - 0:03
 * @Description: api_
 * @version: 1.0
 * 演示 INetAddress 类的使用
 */
public class API_ {
    public static void main(String[] args) throws UnknownHostException {

        //  1.  获取本机的InetAddress 对象
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost);  //LAPTOP-JREQNCE8/192.168.127.1

        //  2.  根据指定主机名 获取 InetAddress对象
        InetAddress host1 = InetAddress.getByName("LAPTOP-JREQNCE8");
        System.out.println(host1);

        //  3.  根据域名返回 InetAddress 对象，比如：www.baidu.com 对应的 InetAddress 对象
        InetAddress host2 = InetAddress.getByName("wwww.baidu.com");
        System.out.println("host2=" + host2); // wwww.baidu.com/220.181.38.148

        //  4.  通过 InetAddress 对象，获取对应的地址
        String hostAddress = host2.getHostAddress();
        System.out.println("host2 对应的 ip " + hostAddress);


        //  5.  通过 IndetAddress 对象，获取对应的主机名 / 或者域名
        String hostName = host2.getHostName();
        System.out.println("host2 对应的主机名 / 域名 " + hostName);
    }
}
```

### 2.7 Socket(套接字) --- TCP / UDP 编程

1. 套接字（Socket）开发网络应用程序被广泛采用，以至于称为事实上的标准
2. 通信的两端都要有 Socket，是两台机器间通信的端点
3. 网络通信其实就是 Socket 间的通信
4. Socket 允许程序把网络连接当成一个流，数据在2个 Socket 间通过 IO 传输
5. 一般主动发起通信的应用程序为客户端，等待通信请求的为服务端

示意图如下：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281251176.png)

当我们获取到一个Socket的时候，通过 Socket 能够拿到管道的 IO 流，然后就可以进行数据的读取操作了

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281253513.png)

 注意：最后一定要关闭服务端的 Socket，如果你不关闭，最终会造成这个服务器，数据连的太多了，再有一个客户端再去连接的时候，后面的就会连不上了。 --- 内存泄漏



### 2.8. TCP网络通信编程

#### 2.8.1 应用案例 1

网络程序的难点在于：

- 有 客户端 和 服务端 2头，两边都要考虑到！！！
- 然后是个网络，涉及到IO流

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281259151.png)

ServerSocket 和 Socket 有什么区别呢???

ServerSocket 可以创建很多个 Socket，只要有一次accept()，就会返回一个 socket(多个客户端访问)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211281301803.png)

服务端代码

```java
package socket_;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/8/27 - 08 - 27 - 18:19
 * @Description: socket_
 * @version: 1.0
 * 服务端
 */
public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {

        //  1.  在本机 9999 端口监听，等待连接（细节：要求 9999 端口未被占用）
        //      细节：这个 ServerSocket 可以通过 accept() 返回多个 Socket【多个客户端连接服务器的并发】
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999 端口监听，等待连接");

        //  2.  当没有客户端连接 9999 端口时，程序会阻塞，等待连接
        //      如果有客户端连接，则会返回 Socket 对象，程序继续
        Socket socket = serverSocket.accept();

        System.out.println("服务端 socket=" + socket.getClass());

        //  3.  通过 socket.getInputStream() 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();  //  (如果客户端没有发消息的话，会在这里等待读入)

        //  4.  IO读取
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));    //  根据读取到的实际长度，显示内容
        }

        //  5.  关闭相关流 和 Socket
        inputStream.close();
        socket.close();
        serverSocket.close();   //  关闭（否则会造成资源的浪费）
        System.out.println("服务端 退出");
    }
}
```

客户端

```java
package socket_;
 
import com.sun.source.tree.Scope;
 
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
 
/**
 * @Author: Ronnie LEE
 * @Date: 2022/8/27 - 08 - 27 - 18:28
 * @Description: socket_
 * @version: 1.0
 * 客户端，发送 "hello, server" 给服务端，
 */
public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
 
        //  1.  连接服务端（ip，端口）---》要连接这台机器的 9999 端口，如果连接成功，会返回一个 socket 对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket返回=" + socket.getClass());
 
        //  2.  连接之后，生成socket，通过 socket.getOutputStream() ，拿到和 socket 对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();
        //  3.  通过输出流。写入数据到 数据通道
        outputStream.write("hello server".getBytes());
        //  4.  关闭流对象和socket，必须关闭
        outputStream.close();
        socket.close();
        System.out.println("客户端退出...");
    }
}
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291119753.png)

#### 2.8.2 应用案例 2 【结束标记：socket.shutdownOutput()】

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291120158.png)

思路如下：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291122115.png)

此时会发现卡住了：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291125344.png)

- 客户端：发送 "hello server"后，服务器 socket在读取的时候。它并不知道什么时候结束
- 服务器：发送"hello client"后，客户端 socket 在读取的时候。它也不知道什么时候结束



【案例1中：客户端发完消息后就关闭了，客户端默认已经接受完了消息，这里的客户端还在等服务端的响应，而客户端也在等客户端继续发消息】

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291132188.png)

在网络编程中，发送完一个数据的时候，应该有一个 <font color="red">结束标记</font>

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291134747.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291136276.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291138051.png)

#### 2.8.3 应用案例3（字符流 BufferedReader / BufferedWriter ===> 处理文本）结束标记 writer.newLine()

为什么用字符流???

- 网络通讯的时候，如果是 <font color="blue">文本</font> 的形式，那么用字符流应该更加方便一些
- 字符流有更多的 <font color="blue">API</font> 来调用，提高我们的效率，代码看起来更加简洁

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291142040.png)

分析思路：

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291142539.png)

关流的顺序一般是：后打开的先关闭



服务器：
```java
package Socket_zifu;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/8/27 - 08 - 27 - 18:19
 * @Description: socket_
 * @version: 1.0
 * 服务端
 */
public class SocketTCP02Server {
    public static void main(String[] args) throws IOException {

        //  1.  在本机 9999 端口监听，等待连接（细节：要求 9999 端口未被占用）
        //      细节：这个 ServerSocket 可以通过 accept() 返回多个 Socket【多个客户端连接服务器的并发】
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999 端口监听，等待连接");

        //  2.  当没有客户端连接 9999 端口时，程序会阻塞，等待连接
        //      如果有客户端连接，则会返回 Socket 对象，程序继续
        Socket socket = serverSocket.accept();

        System.out.println("服务端 socket=" + socket.getClass());

        //  3.  通过 socket.getInputStream() 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();  //  (如果客户端没有发消息的话，会在这里等待读入)

        //  4.  IO 读取，使用字符流，使用转换流 InputStreamReader 将 inputStream 转成了 字符流
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
        String readLine = br.readLine();
        System.out.println(readLine);   //  输出

        //  5.  使用字符输出流的方式回复信息， "hello, client"
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream));
        bw.write("hello, client 字符流");
        bw.newLine();   //  插入一个换行符，表示回复内容（就是写入到这个管道）的结束
        bw.flush(); //  需要手动的 flush

        //  6.  关闭相关流 和 Socket
        bw.close();
        br.close();
        socket.close();
        serverSocket.close();   //  关闭（否则会造成资源的浪费）
        System.out.println("服务端 退出");
    }
}
```

客户端：
```java
package Socket_zifu;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/8/27 - 08 - 27 - 18:28
 * @Description: socket_
 * @version: 1.0
 * 客户端，发送 "hello, server" 给服务端，
 */
public class SocketTCP02Client {
    public static void main(String[] args) throws IOException {

        //  1.  连接服务端（ip，端口）---》要连接这台机器的 9999 端口，如果连接成功，会返回一个 socket 对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket返回=" + socket.getClass());

        //  2.  连接之后，生成socket，通过 socket.getOutputStream() ，拿到和 socket 对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();

        //  3.  通过输出流，写入数据到 数据通道，使用字符流
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream));
        bw.write("hello, server 字符流");
        //  插入一个换行符，表示写入的内容结束.[注意：要求对方使用 readLine() 方式来读取，否则也读取不到内容！！！]
        bw.newLine();
        bw.flush(); //  如果使用字符流，选需要手动刷新，否则数据不会写入数据通道


        //  4.  通过输入流，读取 服务器发送的 "hello, client字符流"
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
        String readLine = br.readLine();
        System.out.println(readLine);


        //  5.  关闭流对象和socket，必须关闭
        br.close();   //  直接关闭外层流() ---》 关闭外层缓冲流，内层自动关闭
        bw.close();
        socket.close();
        System.out.println("客户端退出...");
    }
}
```

#### 2.8.4 应用案例4（字节流 BufferedInputStream / BufferedOutputStream ===> 处理图片）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291151905.png)

将客户端的图片，通过网络上传到服务器，而且服务器回复消息

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291157520.png)

1. 客户端先用字节流将图片（二进制的 ---> 要用***\*字节\****数组）读取到内存中
2. 通过Socket，获取到一个输出流，写入服务器(黄色的线)
3. 服务器端通过 Socket 获取一个输入流，用字节流读取图片
4. 再写入到 一个指定的目录（flush 到磁盘上）
5. 再将返回信息写给客户端，客户端读取并打印
6. 最后客户端还要有个输入流，把服务器的打印读出来



StreamUtils：演示关于流的读写方法

```java
//	首先：数组是要定义容量大小的，一开始读取的时候，无法确定大小
//	1024 只是缓冲区 大小

//	图片 ---> 字节流 ---> 字符数组流
```



```java
package upload;
 
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
 
/**
 * 此类用于演示关于流的读写方法
 *
 */
public class StreamUtils {
	/**
	 * 功能：将输入流转换成byte[] ---> 即：可以把一个文件写入（输出）到 byte[]
	 * @param is
	 * @return
	 * @throws Exception
	 */
	public static byte[] streamToByteArray(InputStream is) throws Exception{	//	可以接受一个输入流，当然InputStream是
																				//	一个抽象类，所以只要是它的子类对象
																				//	都可以传进来
		ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象
		byte[] b = new byte[1024];	//	字节数组
		int len;
		while((len=is.read(b))!=-1){	//	循环读取
			bos.write(b, 0, len);	//	读取到的数据（字节数组），写入到 bos 中去
		}
		byte[] array = bos.toByteArray();	//	然后将 bos 转成一个字节数组
		bos.close();
		return array;
	}
	/**
	 * 功能：将InputStream转换成String
	 * @param is
	 * @return
	 * @throws Exception
     * 将输入流的数据直接给你转成一个字符串
	 */
	
	public static String streamToString(InputStream is) throws Exception{
		BufferedReader reader = new BufferedReader(new InputStreamReader(is));
		StringBuilder builder= new StringBuilder();
		String line;
		while((line=reader.readLine())!=null){  //    当读取到 null 时，就表示结束
			builder.append(line+"\r\n");
		}
		return builder.toString();
		
	}
 
}
```

问：为何不把图片直接转换成字节数组流，非要弄成字节流，字节流再转换成字节数组流

因为：直接弄，不知道要开多大的数组



说白了，就是4条线：【输入流和输出流在不停的变化】

1. 将磁盘上的文件读入到字节数组中
2. 通过Socket拿到一个输出流，把字节数组的内容打到数据通道 
3. 服务端通过Scoket 得到一个输入流，把数据拿到过后，通过工具类，得到一个字节数组
4. 再把字节数组通过一个输出流写到某个目录中



服务器：

```java
public class TCPFileUploadServer {
    public static void main(String[] args) throws Exception {
 
        //  1.  服务端在本机监听 8888 端口
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println("服务端在 8888 端口监听...");
        //  2.  等待连接
        Socket socket = serverSocket.accept();
 
        /********************************************************/
 
        //  3.  读取客户端发送的数据
        //  通过 Socket 得到输入流
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = StreamUtils.streamToByteArray(bis);
 
        //  4.  将得到的 bytes 数组，写入到指定的路径，就得到一个文件了
        String desFilePath = "src/qie2.png";
        //  因为是 “写入”，那么肯定需要一个输出流，输出流就要和一个文件相关联了
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desFilePath));
        bos.write(bytes);
        bos.close();
 
        /**************************************/
        //  向客户端回复 “收到图片” ---> 通过Socket 拿到一个输出流（字节流或者字符流都行）
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
        bw.write("服务端收到图片");
        bw.flush(); //  把内容刷新到数据通道
        socket.shutdownOutput();    //  设置写入    结束标记
 
 
        //  关闭其它资源
        bw.close();
        bis.close();
        socket.close();
        serverSocket.close();
    }
}
```

客户端

```java
public class TCPFileUploadClient {
    public static void main(String[] args) throws Exception {
 
        String filePath = "F:/企鹅.png";
 
        //  客户端连接服务器 8888，得到 Socket 对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);
 
        //  创建读取磁盘文件的输入流（因为是二进制文件，所以用处理流 BufferedInputStream）
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));
        //  怎么把一个文件读取到字节数组中呢（调用 StreamUtils）
        //  这个 bytes 就是 filePath 对应的字节数组
        byte[] bytes = StreamUtils.streamToByteArray(bis);
 
        //  通过 socket 获取到 输出流，将 bytes 数据发送到服务端
        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());  //  从socket 得到的输出流 转成 Buffered 的输出流，这样控制起来会轻松一点
        bos.write(bytes);   //  将文件对应的字节数组的内容，写入到数据通道里
        bis.close();
        socket.shutdownOutput();    //  设置写入数据的结束标记
 
        /******************************************************/
 
        //  从 Socket 获取传入进来的信息，你可以用字节流 / 字符流
        InputStream inputStream = socket.getInputStream();
        /*********  前面讲过一个工具类，那个工具类还有一个方法 **********/
        //  使用 StreamUtils 方法，直接将 inputStream 读取到的内容 转换成字符串
        String string = StreamUtils.streamToString(inputStream);
        System.out.println(string);
 
 
        //  关闭相关的流
        inputStream.close();
        bos.close();
        socket.close();
 
    }
}
```

### 2.9 netstat 

#### 2.9.1 netstat -an

查看当前主机网络情况、包括 <font color="red">端口监听</font> 情况和 <font color="red">网络连接</font> 情况

#### 2.9.2 netstat -an | more 分页显示

相当于服务器端口在 8888 端口监听

外部地址：往往指的是客户端

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291540237.png)

说明：

- Listening：表示某个端口在监听
- 如果有一个外部程序（客户端）连接到端口，就会显示一条连接信息

我们能不能看到监听的程序是哪个程序呢?

使用管理员模式打开 cmd

```bash
netstat -anb | more
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291543350.png)

## 3. TCP连接的秘密

1. 当客户端连接到服务器后，实际上客户端也是通过一个端口和服务器进行通讯的（这个端口是 TCP / IP 来分配的，是不确定的，随机的）

   ![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291547520.png)

为了方便监控，我们来传入一个视频

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291549564.png)

当整个传入结束之后，这个 5088 端口就被释放了

```java
netstat -ano|findstr "8888"
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291557187.png)

这个知识点非常的重要，后面在学习高并发的时候，为什么端口是有限的，为什么会出现端口冲突，不然的话你搞不清楚它的底层机制

## 4. UDP 网络通信编程 【了解】

没有服务端和客户端的概念 --- 类似手机发短信

发送数据前，先建立数据包 / 报 DatagramPacket 对象

### 4.1 基本介绍

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291600899.png)

### 4.2 基本流程

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291601088.png)

### 4.3 UDP 网络编程原理示意图

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291602277.png)

看下 DatagramPacket 构造器

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291604320.png)

### 4.4 应用实例

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291604910.png)

发送端：

```java
package udp;

import java.io.IOException;
import java.net.*;

/**
 * 发送端B ===> 也可以接收数据
 */
public class UDPSenderB {
    public static void main(String[] args) throws IOException {

        //  1）创建 DatagramSocket 对象，准备在 9998 端口接收数据
        DatagramSocket socket = new DatagramSocket(9998);

        //  2）将需要发送的数据，封装到 DatagramPacket 对象
        byte[] data = "hello, 明天吃火锅".getBytes();

        //  说明：封装的 DatagramPacket 对象 data 内容字节数组，data.length, 主机（IP），端口
        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.8.161"), 9999);
        socket.send(packet);

        /************************接收从A端口回复的信息**************************/
        //   构建一个 DatagramPacket 对象，准备接收数据
        //   在前面讲解 UDP 协议时，讲过一个数据包最大 64 K
        byte[] buf = new byte[1024];
        packet = new DatagramPacket(buf, buf.length);   //  更新 packet

        //  调用 接收方法，将通过网络传输的 DatagramPacket 对象
        //  填充到 packet对象
        //  提示：当有数据包发送到 本机的 9998 端口时，就会接收到数据
        //  如果没有数据包发送到本机的 9998 端口，就会阻塞等待
        socket.receive(packet);
        
        //  可以把 packet 进行拆包，取出数据，并显示
        int length = packet.getLength();    //  实际接收到的数据字节长度
        data = packet.getData();     //  接收到的数据
        String s = new String(data, 0, length);
        System.out.println(s);


        //  关闭资源
        socket.close();
        System.out.println("B端退出...");
    }
}
```

接收端

```java
package udp;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

/**
 * 接收端A
 */
public class UDPReceiverA {
    public static void main(String[] args) throws IOException {

        //  1） 创建一个 DatagramSocket 对象，准备在9999 端口接收数据
        DatagramSocket socket = new DatagramSocket(9999);
        //  2） 构建一个 DatagramPacket 对象，准备接收数据
        //      在前面讲解 UDP 协议时，讲过一个数据包最大 64 K
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        //  3） 调用 接收方法，将通过网络传输的 DatagramPacket 对象
        //  填充到 packet对象
        //  提示：当有数据包发送到 本机的 9999 端口时，就会接收到数据
        //  如果没有数据包发送到本机的 9999 端口，就会阻塞等待
        System.out.println("接收端A 等待接收数据...");
        socket.receive(packet);

        //  4） 可以把 packet 进行拆包，取出数据，并显示
        int length = packet.getLength();    //  实际接收到的数据字节长度
        byte[] data = packet.getData();     //  接收到的数据
        String s = new String(data, 0, length);
        System.out.println(s);

        /*********************回复信息给B端********************************/
        //   将需要发送的数据，封装到 DatagramPacket 对象
        data = "好的，明天见".getBytes(); //  相当于数据更新了一下（要不直接复制过来，会有变量冲突）

        //  说明：封装的 DatagramPacket 对象 data 内容字节数组，data.length, 主机（IP），端口
        packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.8.161"), 9998);
        socket.send(packet);

        //  5）关闭资源
        socket.close();
        System.out.println("A端退出...");

    }
}
```

![image-20221129162712220](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291627474.png)

![image-20221129162847647](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291628750.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291631949.png)

## 5. 课后作业

### 5.1 聊天

- 字符流
- name ---> 名字，hobby ---> 编写 java 程序
- 你说啥呢?

服务端

```java
/**
 * 服务端
 */
public class Homework01Server {
    public static void main(String[] args) throws IOException {

        //  1.  在本机 9999 端口监听，等待连接（细节：要求 9999 端口未被占用）
        //      细节：这个 ServerSocket 可以通过 accept() 返回多个 Socket【多个客户端连接服务器的并发】
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999 端口监听，等待连接");

        //  2.  当没有客户端连接 9999 端口时，程序会阻塞，等待连接
        //      如果有客户端连接，则会返回 Socket 对象，程序继续
        Socket socket = serverSocket.accept();

        System.out.println("服务端 socket=" + socket.getClass());

        //  3.  通过 socket.getInputStream() 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();  //  (如果客户端没有发消息的话，会在这里等待读入)

        //  4.  IO 读取，使用字符流，使用转换流 InputStreamReader 将 inputStream 转成了 字符流
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
        String s = br.readLine();
        String answer = "";
        if ("name".equals(s)){
            answer = "我是爱新觉罗LQ";
        }else if ("hobby".equals(s)){
            answer = "编写Java程序";
        }else {
            System.out.println("你在说几把啥！！！");
        }

        //  5.  使用字符输出流的方式回复信息， "hello, client"
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream));
        bw.write(answer);
        bw.newLine();   //  插入一个换行符，表示回复内容（就是写入到这个管道）的结束
        bw.flush(); //  需要手动的 flush

        //  6.  关闭相关流 和 Socket
        bw.close();
        br.close();
        socket.close();
        serverSocket.close();   //  关闭（否则会造成资源的浪费）
        System.out.println("服务端 退出");
    }
}
```

客户端：

```java
/**
 * 客户端，发送 "hello, server" 给服务端，
 */
public class Homework01Client {
    public static void main(String[] args) throws IOException {

        //  1.  连接服务端（ip，端口）---》要连接这台机器的 9999 端口，如果连接成功，会返回一个 socket 对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket返回=" + socket.getClass());

        //  2.  连接之后，生成socket，通过 socket.getOutputStream() ，拿到和 socket 对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();

        //  3.  通过输出流，写入数据到 数据通道，使用字符流
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(outputStream));

        //  从键盘读取用户的问题
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入你的问题");
        String question = scanner.next();

        bw.write(question);
        bw.newLine();
        bw.flush(); //  如果使用字符流，选需要手动刷新，否则数据不会写入数据通道


        //  4.  通过输入流，读取 服务器发送的 "hello, client字符流"
        InputStream inputStream = socket.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
        String readLine = br.readLine();
        System.out.println(readLine);


        //  5.  关闭流对象和socket，必须关闭
        br.close();   //  直接关闭外层流() ---》 关闭外层缓冲流，内层自动关闭
        bw.close();
        socket.close();
        System.out.println("客户端退出...");
    }
}
```

### 5.2 UDP

询问四大名著是什么

接收端

```java
/**
 * 接收端A
 */
public class Homework02Receiver {
    public static void main(String[] args) throws IOException {

        //  1） 创建一个 DatagramSocket 对象，准备在8888 端口接收数据
        DatagramSocket socket = new DatagramSocket(8888);
        //  2） 构建一个 DatagramPacket 对象，准备接收数据
        //      在前面讲解 UDP 协议时，讲过一个数据包最大 64 K
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);

        //  3） 调用 接收方法，将通过网络传输的 DatagramPacket 对象
        //  填充到 packet对象
        System.out.println("接受端  等待接收问题 ");
        socket.receive(packet);

        //  4） 可以把 packet 进行拆包，取出数据，并显示
        int length = packet.getLength();    //  实际接收到的数据字节长度
        byte[] data = packet.getData();     //  接收到的数据
        String s = new String(data, 0, length);
        System.out.println(s);
        //  判断接收到的信息是什么
        String answer = "";
        if ("四大名著是哪些".equals(s)){
            answer = "红三西水";
        }else{
            answer = "nani";
        }

        /*********************回复信息给B端********************************/
        //   将需要发送的数据，封装到 DatagramPacket 对象
        data = answer.getBytes(); //  相当于数据更新了一下（要不直接复制过来，会有变量冲突）

        //  说明：封装的 DatagramPacket 对象 data 内容字节数组，data.length, 主机（IP），端口
        packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.8.196"), 9998);
        socket.send(packet);

        //  5）关闭资源
        socket.close();
        System.out.println("A端退出...");
    }
}
```

发送端

```java
/**
 * 发送端B ===> 也可以接收数据
 */
public class Homework02Sender {
    public static void main(String[] args) throws IOException {

        //  1）创建 DatagramSocket 对象，准备在 9998 端口接收数据
        DatagramSocket socket = new DatagramSocket(9998);

        //  2）将需要发送的数据，封装到 DatagramPacket 对象
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入你的问题：");
        String question = scanner.next();

        byte[] data = question.getBytes();

        //  说明：封装的 DatagramPacket 对象 data 内容字节数组，data.length, 主机（IP），端口
        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.8.196"), 8888);
        socket.send(packet);

        /************************接收从A端口回复的信息**************************/
        //   构建一个 DatagramPacket 对象，准备接收数据
        //   在前面讲解 UDP 协议时，讲过一个数据包最大 64 K
        byte[] buf = new byte[1024];
        packet = new DatagramPacket(buf, buf.length);   //  更新 packet

        //  调用 接收方法，将通过网络传输的 DatagramPacket 对象
        //  填充到 packet对象
        //  提示：当有数据包发送到 本机的 9998 端口时，就会接收到数据
        //  如果没有数据包发送到本机的 9998 端口，就会阻塞等待
        socket.receive(packet);

        //  可以把 packet 进行拆包，取出数据，并显示
        int length = packet.getLength();    //  实际接收到的数据字节长度
        data = packet.getData();     //  接收到的数据
        String s = new String(data, 0, length);
        System.out.println(s);

        //  关闭资源
        socket.close();
        System.out.println("B端退出...");
    }
}
```

### 5.3 返回音乐文件

客户端发出文件名称，服务端返回对应文件，如果没有就返回默认

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291757995.png)

服务端

```java
/**
 * 先写文件下载服务端
 */
public class Homework03Server {
    public static void main(String[] args) throws Exception {

        //  1 监听9999 端口
        ServerSocket serverSocket = new ServerSocket(9999);
        //  2 等待客户端连接
        Socket socket = serverSocket.accept();
        //  3 读取 客户端发送的 要下载的文件名
        //  先得到一个输入的对象
        //  这里老师使用了 while 读取文件名，同时考虑将来客户端发送的数据较大的情况
        InputStream inputStream = socket.getInputStream();
        byte[] bytes = new byte[1024];
        int len = 0;
        String downLoadFileName = "";
        while ((len = inputStream.read(bytes))!= -1) {
            downLoadFileName += new String(bytes, 0, len);
        }
        System.out.println("客户端希望下载文件名=" + downLoadFileName);

        //  老师在服务器上有2个文件，无名，高山流水
        //  如果客户下载的是高山流水，我们就返回该文件，否则一律返回无名

        String resFileName = "";
        if ("高山流水".equals(downLoadFileName)){
            resFileName = "src/高山流水.mp3";
        } else {
            resFileName = "src/无名.mp3";
        }

        //  4.  创建一个输入流，读取文件
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(resFileName));

        //  5.  使用工具类 StreamUtils，读取文件到一个字节数组
        byte[] bytes1 = StreamUtils.streamToByteArray(bis);

        //  6.  在得到socket 关联的输出流
        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());

        //  7.  写入到数据通道，返回给客户端
        bos.write(bytes1);
        socket.shutdownOutput();    //  很关键

        //  8.  关闭相关资源
        bis.close();
        bos.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
```

```java
/**
 * 文件下载的客户端
 */
public class Homework03Client {
    public static void main(String[] args) throws Exception {

        //  1.  接收用户输入，指定下载文件名
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入下载文件名");
        String downloadFileName = scanner.next();

        //  2.  客户端连接服务端，准备发送
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        //  3.  获取和 Socket 关联的输出流
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(downloadFileName.getBytes());
        //  设置写入结束的标识
        socket.shutdownOutput();

        //  4.  读取服务端返回的文件（字节数组）
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        //  5.  使用工具类
        byte[] bytes = StreamUtils.streamToByteArray(bis);

        //  6.  得到一个输出流，准备将 bytes 写入到磁盘文件
        String filePath = "e:/" + downloadFileName + ".mp3";
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));
        bos.write(bytes);

        //  7.  关闭相关的资源
        bos.close();
        bis.close();
        outputStream.close();
        socket.close();
        System.out.println("客户端下载完毕，正确退出了...");


    }
}
```

## 6. 网络编程梳理

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291802080.png)

| TCP / IP 模型【 4层 】 | 作用                                              |
| ---------------------- | ------------------------------------------------- |
| 应用层                 | 主要和应用程序打交道的                            |
| 传输层（TCP）          | TCP、UDP...                                       |
| 网络层（IP）           | 用来定位的                                        |
| 物理+数据链路层        | 把数据变成 帧数据 ---> 就可以在网络里面进行传输了 |

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291807278.png)

## 7. 多用户通信系统

QQ聊天项目展示

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291809557.png)

- 项目框架设计
- java OOP
- 网络编程
- 多线程
- IO流
- Mysql / 使用集合充当内存数据库

### 7.1 项目开发流程

需求分析 ---》设计阶段 ---》实现阶段 ---》测试阶段 ---》实施阶段 ---》维护阶段 

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291810600.png)

项目越大（需求分析和设计阶段花费的时间就越长）

国内一般是一边实现，一边再去写文档

### 7.2 多用户即时通信系统需求分析

1. 用户登录
2. 拉取在线用户列表
3. 无异常退出（客户端、服务端）
4. 私聊
5. 群聊
6. 发文件
7. 文件服务器推送新闻

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291819249.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291820455.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291820373.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291821742.png)

### 7.3 通信系统整体分析

#### 7.3.1 对象流 [ObjectInputStream / ObjectOutputStream]

​        我们整个程序在进行处理的时候，它的信息种类比较多，我们是以对象的方式进行处理的，之前学IO流的时候，有一个叫做 <font color="red">对象流</font> ，可以读取对象的， ObjectInputStream和ObjectOutputStream，所以我们在进行通讯的时候，我们会优先考虑传输这种  Message 对象或者是 User对象，以对象的方式来进行数据的传输。

#### 7.3.2 串行化

​		如果客户端要与服务器进行一个通信，我就发一个 <font color="red">串行化</font> 的对象，而不再是简单的字符串了，因为这个消息里面包含的信息比较多，如果还以字符串的形式来进行信息的交流，势必造成服务端在拿到这个数据以后，对它进行一个拆解或者处理，肯定会很麻烦。

​		![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291825539.png)

主线程持续监听，子线程通信（线程持有一个 <font color="blue">socket</font> ，或者说 socket 是线程的一个属性）

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291827113.png)

#### 7.3.4 管理线程的集合

客户端和服务端都有很多线程，需要有管理线程的集合

- 客户端B群发消息，服务器需要来处理响应
- 客户端A打QQ视频的同时还在和别人聊QQ

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291836897.png)

### 7.4 具体实现

#### 1. 用户登录

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291838241.png)

这3个文件是客户端和服务器共享的，给客户端也复制一份

```java
package QQClient.qqcommon;

import java.io.Serializable;

/**
 * 表示客户端和服务端通信时的消息对象
 */
public class Message implements Serializable {
    //  为了增加兼容性
    private static final long serialVersionUID =1L;

    private String sender;  //  发送者
    private String receiver;    //  接收者
    private String content;    //  消息内容
    private String sendTime;    //  发送时间

    //  我们未来的消息类型很多，所以我们需要在这里再加一个字段
    private String mesType; //  消息类型 [可以在接口中定义消息类型]

    public String getSender() {
        return sender;
    }

    public void setSender(String sender) {
        this.sender = sender;
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getSendTime() {
        return sendTime;
    }

    public void setSendTime(String sendTime) {
        this.sendTime = sendTime;
    }

    public String getMesType() {
        return mesType;
    }

    public void setMesType(String mesType) {
        this.mesType = mesType;
    }
}
```

```java
/**
 * 表示消息类型
 */
public interface MessageType {
    //  1）在接口中定义了一些常量
    //  2) 不同的常量值，表示不同的消息类型
    String MESSAGE_LOGIN_SUCCEED = "1"; //  表示登录成功
    String MESSAGE_LOGIN_FAIL = "2"; //  表示登录失败
    String MESSAGE_COMM_MES = "3";  //  普通信息包
    String MESSAGE_GET_ONLINE_USERS = "4";  //  请求返回在线用户列表
    String MESSAGE_RET_ONLINE_USERS = "5";  //  返回在线用户列表
    String MESSAGE_CLIENT_EXIT = "6";  //  客户端退出请求
    String MESSAGE_TO_ALL_MES = "7";  //  群发消息报
}

```

```java
/**
 * 表示一个用户/客户信息
 */
public class User implements Serializable {
    //  为了增加兼容性
    private static final long serialVersionUID =1L;

    private String userId;
    private String passwd;

    public User(String userId, String passwd) {
        this.userId = userId;
        this.passwd = passwd;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getPasswd() {
        return passwd;
    }

    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }
}
```

这里用到了工具类 Utility【处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入】

##### 功能说明

暂时规定：用户名 / id = 100，密码：123456就可以登录，其它用户不饿能登录

后面使用 HashMap 模拟数据库，可以多个用户登录

![image-20221129192540682](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291925772.png)

##### 核心代码

发送对象给服务器读取，然后服务器端形成线程集合

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291926167.png)

##### User对象 / Message 对象

- 客户端连接服务器，发送一个 User 对象
- 服务器拿到这个 User 对象信息以后，进行读取，并验证这个 User 对象是否和合法
- 给 客户端和你回复一个 Message 对象
- 最后客户端依据这个 Message 对象的类型和结果来判定是否登录成功



###### 客户端目录

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291931328.png)

###### 服务器目录

服务器怎么来验证 User 对象，然后回复给 客户端 Message 对象

之前客户端已经发过来 User 对象

- 服务器要完成监听
- 启动一个线程，这个线程（持有 Socket）保持和客户端的一个通讯

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291942770.png)

启动 <font color="yellow">线程 </font>的目的：在连通之后，和客户端 <font color="red">保持通信</font>

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291946663.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211291946092.png)

到此为止，通道已经打通了，下面还要考虑客户但和服务器的业务代码了

1. 客户端业务

```java
/**
 * 该类完成用户登录验证和用户注册等功能
 */
public class UserClientService {

    //  因为我们可能在其它地方使用user信息，因此设计成成员属性（可以利用set和get方法进行访问）
    private User user = new User();
    //  因为 Socket 在其它地方也要使用，因此也做成属性【将来还要存放在线程里面的】
    private Socket socket;

    //  根据 userId 和 pwd 到服务器验证该用户是否合法
    public boolean checkUser(String userId, String pwd) {
        boolean b = false;  //  变量 b 判断 checkUser 是否通过

        //  设置 user对象属性
        user.setUserId(userId);
        user.setPasswd(pwd);
        //  连接到服务端，发送 user对象
        try {
            socket = new Socket("192.168.8.228", 9999);
            //  得到 ObjectOutputStream 对象
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);  // 发送 user 对象

            //  读取从服务器回复的 Message 对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();  //  向下转型

            if ((MessageType.MESSAGE_LOGIN_SUCCEED).equals(ms.getMesType())){   //  登录成功了

                b = true;
                //  创建一个和服务器端保持通信的线程  ---> 创建一个类 ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread = new ClientConnectServerThread(socket);
                //  启动客户端的线程
                clientConnectServerThread.start();        
            } else {
                //  如果登录失败，就不能启动和服务器通信的线程，要关闭 Socket
                socket.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return b;
    }


    //  编写方法，退出客户端，并给服务端发送一个退出系统得 message 对象
    public void logout() {
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
        message.setSender(user.getUserId());    //  一定要指定我是哪个 客户端 id
        
        //  发送 message
        try {
            //  将来如果有多个 socket 时，按照如下方法来写
            //  不然的话，你这个退出的消息就不知道怎么发了
            //  从管理线程得 集合（ManageClientConnectServerThread）里面获取一个线程（根据userId），再拿到对应得 socket，然后再去获得它的一个输出流对象
             ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
//            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(message);
            System.out.println(user.getUserId() + "退出系统 ");
            System.exit(0); //  结束进程
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

2. 客户端线程

   ```java
   public class ClientConnectServerThread extends Thread{
       //  该线程需要持有 Socket
       private Socket socket;
   
       //  构造器可以接收一个 Socket 对象
       public ClientConnectServerThread(Socket socket) {
           this.socket = socket;
       }
   
       //  为了更方便地得到 Socket
       public Socket getSocket() {
           return socket;
       }
   
       @Override
       public void run() {
           //  因为 Thread 需要在后台和服务进行通信，因此使用 while循环
           while (true) {
               System.out.println("客户端线程，等待读取从服务器发来的消息");
               try {
                   ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //  通过 socket 获取 流对象
                   Message ms = (Message) ois.readObject();    //  如果服务器没有发送 Message 对象，线程会阻塞在这里
   
                   //  注意，后面我们需要去使用 message
                   //  判断这个 message 类型，然后做相应的业务处理
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   
   ```

3. 服务器业务

```java
/**
 * 这是服务端，监听9999端口，等待客户端链接诶，并保持通信
 */
public class QQServer {

    private ServerSocket serverSocket = null;

    //  创建一个集合，存放多个用户，如果是这些用户登录，就认为合法
    //  这里也可以使用 ConcurrentHashMap，可以处理并发的集合，没有线程安全
    //  HashMap 没有处理线程安全，因此在多线程情况下是不安全的
    //  ConcurrentHashMap 处理的线程安全，即线程同步处理，在多线程情况下是安全
    private static HashMap<String, User> validUsers = new HashMap<>();

    static {    //  在静态代码快中，初始化 validUsers
        validUsers.put("100", new User("100", "123456"));
        validUsers.put("200", new User("200", "123456"));
        validUsers.put("300", new User("300", "123456"));
        validUsers.put("至尊宝", new User("至尊宝", "123456"));
        validUsers.put("紫霞仙子", new User("紫霞仙子", "123456"));
        validUsers.put("菩提老祖", new User("菩提老祖", "123456"));

    }

    //  验证用户是否有效
    private boolean checkUser(String uerId, String passwd) {

        User user = validUsers.get(uerId);
        //  过关斩将法
        if (user == null) { //  说明 userId没有存在 validUsers 的key 中
            return false;
        }
        if (!(passwd.equals(user.getPasswd()))){   //  userId 正确，但是密码错误
             return false;
        }
        return true;
    }


    public QQServer() {
        //  注意，端口可以卸载配置文件中
        System.out.println("服务端在9999端口监听...");
        try {
            serverSocket = new ServerSocket(9999);

            while (true) {  //  当和某个客户端建立链接后，会继续监听，因此while循环
                Socket socket = serverSocket.accept();  //  如果没有客户端连接，就会阻塞在这里
                //  得到 socket 关联的对象输入流
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                User user = (User)ois.readObject(); //  我们事先知道，客户端发过来的是 User 对象 ---> 向下转型

                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());

                //  创建一个Message 对象，准备回复给客户端 [不管成功与否，都需要给客户端回复一个 Message]
                Message message = new Message();

                //  验证
                if (checkUser(user.getUserId(), user.getPasswd())){
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    //  将 Message 对象回复
                    oos.writeObject(message);
                    //  创建一个线程，和客户端保持通信，同时该线程需要持有 Socket 对象
                    ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, user.getUserId());
                    //  启动线程
                    serverConnectClientThread.start();
                }else{  //  登录失败
                    System.out.println("用户 id=" + user.getUserId() + "pwd=" + user.getPasswd() + "验证失败");
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    //  关闭socket
                    socket.close();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //  如果服务器退出了 while，说明服务器不再监听，因此关闭 ServerSocket
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}

```

4. 服务器线程

   ```java
   /**
    * 该类的一个对象和某个客户端保持通信
    */
   public class ServerConnectClientThread extends Thread{
       private Socket socket;
       private String userId; //   连接到服务端的用户 id
   
       public ServerConnectClientThread(Socket socket, String userId) {
           this.socket = socket;
           this.userId = userId;
       }
   
       public Socket getSocket() {
           return socket;
       }
   
       @Override
       public void run() { //  这里线程处于 run 状态，可以发送 / 接收消息
           while (true){
               System.out.println("服务端和客户端" +  userId + "保持通信，读取数据...");
               try {
                   ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                   Message message = (Message) ois.readObject();
                   //  后面会使用 message,根据message的类型，做相应的业务处理
               } catch (Exception e) {
                   e.printStackTrace();
               }
           }
       }
   }
   ```

###### 使用 HashMap 模拟数据库，让多个用户登录

```java
private static HashMap<String, User> validUsers = new HashMap<>();

    static {    //  在静态代码快中，初始化 validUsers
        validUsers.put("100", new User("100", "123456"));
        validUsers.put("200", new User("200", "123456"));
        validUsers.put("300", new User("300", "123456"));
        validUsers.put("至尊宝", new User("至尊宝", "123456"));
        validUsers.put("紫霞仙子", new User("紫霞仙子", "123456"));
        validUsers.put("菩提老祖", new User("菩提老祖", "123456"));
    }

```

#### 2. 拉取用户列表

如果用户登录成功以后，可以进一步进行选择

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211292057559.png)

这2个线程都有自己的 Socket ，而且不停地读取

- 如果客户端想要获得所有在线用户的列表，就要像服务器发送请求去要
- 只有服务器才知道有哪些用户上线了【拥有所有用户的 UID】
- 即：客户端发送 message 对象 给服务器，服务器就读取信息，看客户端想要什么

message 可能有不同的种类：

1. 获取在线用户列表
2. 群发消息

所以我们先来对 message 对象的种类进行一个<font color="red"> 扩展</font>

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301254321.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301258433.png)

将来我们客户端可能会有多个线程  ---> 应当获得<font color="yellow"> 当前</font> 线程的 Socket 对应的 oos 对象

首先呢，我们知道所有线程是放在 <font color="red"> 管理线程的集合 </font>里面的

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301318441.png)

##### 客户端

###### getOnLineUsersList()

在 UserClientService中编写方法

```java
//  向服务器端请求在线用户列表
public void getOnLineUsersList() {

    //  发送一个 Message，类型是 String MESSAGE_GET_ONLINE_USERS
    Message message = new Message();
    message.setMesType(MessageType.MESSAGE_GET_ONLINE_USERS);
    try {
        //  发送给服务器
        //  将来客户端也有可能有多个线程 ---> 应该获得当前线程的 Socket 对应的 oos 对象
        ClientConnectServerThread clientConnectServerThread = ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()); //    根据 UserID 获取对应线程
        Socket socket = clientConnectServerThread.getSocket();  //  获取对应的 socket
        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
        oos.writeObject(message);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

###### ManageClientConnectServerThread

```java
/**
 * 该类管理客户端连接到服务端的线程的类
 */
public class ManageClientConnectServerThread {
    //  我们把多个线程放入一个 HashMap 集合
    //	key 就是用户 id
    //	value 就是  线程
    private static HashMap<String, ClientConnectServerThread> hm = new HashMap<>();

    //  将某个线程加入到集合
    public static void addClientConnectServerThread(String userId, ClientConnectServerThread clientConnectServerThread) {
        hm.put(userId, clientConnectServerThread);
    }

    //  通过 userId 可以得到对应线程
    public static ClientConnectServerThread getClientConnectServerThread(String usrId){
        return hm.get(usrId);
    }
}
```



Scoket 是在 checkUser 中创建的，每登录成功一次，就会创建一个 socket，并启动线程，放到 hm 中进行统一管理

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301321255.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301322934.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301323851.png)

=======================================================================================================

下面开始写服务端的代码了

服务器端有很多线程，但是每一个通道对应一个线程，在这个线程中，一致处于 <font color="yellow">读对象</font> 的这样一种状态，如果有数据来了就读到了，就看这个 message 是什么类型的

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301336261.png)

##### 服务端

###### ServerConnectClientThread 线程

```java
/**
 * 该类的一个对象和某个客户端保持通信
 */
public class ServerConnectClientThread extends Thread{
    private Socket socket;
    private String userId; //   连接到服务端的用户 id

    public ServerConnectClientThread(Socket socket, String userId) {
        this.socket = socket;
        this.userId = userId;
    }

    public Socket getSocket() {
        return socket;
    }

    @Override
    public void run() { //  这里线程处于 run 状态，可以发送 / 接收消息
        while (true){
            System.out.println("服务端和客户端" +  userId + "保持通信，读取数据...");
            try {
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                Message message = (Message) ois.readObject();
                //  后面会使用 message,根据message的类型，做相应的业务处理
                if(MessageType.MESSAGE_GET_ONLINE_USERS.equals(message.getMesType())) {
                    //  在线用户列表形式 100  200  紫霞仙子 ---》管理线程集合中知道，那么在这里编写方法
                    System.out.println(message.getSender() + "正在请求在线用户列表");
                    String onlineUsers = ManageServerConnectClientThread.getOnlineUsers();
                    //  返回 message
                    //  构建一个 message 对象[类型，内容]，返回给客户端
                    Message message1 = new Message();
                    message1.setMesType(MessageType.MESSAGE_RET_ONLINE_USERS);
                    message1.setContent(onlineUsers);
                    message1.setReceiver(message.getSender());  //  设置message1接收者[即：message 的发送者]，
                    //  返回给客户端
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message1);
                } else {
                    System.out.println("其他类型的 message，暂时不处理");
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

####### ManageServerConnectClientThread

###### ManageServerConnectClientThread

在 ManageServerConnectClientThread 中编写方法 getOnlineUsers()，返回在线用户里列表

```java
/**
 * 用于管理和客户端通信的线程
 *	key ：用户 id
 *	value: 线程
 */
public class ManageServerConnectClientThread {
    private static HashMap<String, ServerConnectClientThread> hm = new HashMap<>();

    //  返回 HashMap 集合 hm
    public static HashMap<String, ServerConnectClientThread> getHm() {
        return hm;
    }

    //  添加线程对象到 hm 集合
    public static void addServerConnectClientThread(String userId, ServerConnectClientThread serverConnectClientThread) {
        hm.put(userId, serverConnectClientThread);
    }
    //  根据 userId 返回 ServerConnectClientThread 线程
    public static ServerConnectClientThread getServerConnectClientThread(String userId) {
        return hm.get(userId);
    }

    //  编写方法，返回在线用户列表
    public static String getOnlineUsers() {
        //  集合的遍历，遍历 hm 的 key
        Iterator<String> iterator = hm.keySet().iterator();
        String onLineUserList = "";

        while (iterator.hasNext()) {
            onLineUserList += iterator.next().toString() + " ";
        }

        return onLineUserList;
    }

    //  增加一个方法，从集合中，移除某个线程对象
    public static void removeServerConnectionThread(String userId) {
        hm.remove(userId);
    }
}
```

###### QQServer

```java
/**
 * 这是服务端，监听9999端口，等待客户端连接，并保持通信
 */
public class QQServer {

    private ServerSocket serverSocket = null;

    //  创建一个集合，存放多个用户，如果是这些用户登录，就认为合法
    //  这里也可以使用 ConcurrentHashMap，可以处理并发的集合，没有线程安全
    //  HashMap 没有处理线程安全，因此在多线程情况下是不安全的
    //  ConcurrentHashMap 处理的线程安全，即线程同步处理，在多线程情况下是安全
    private static HashMap<String, User> validUsers = new HashMap<>();

    static {    //  在静态代码快中，初始化 validUsers
        validUsers.put("100", new User("100", "123456"));
        validUsers.put("200", new User("200", "123456"));
        validUsers.put("300", new User("300", "123456"));
        validUsers.put("至尊宝", new User("至尊宝", "123456"));
        validUsers.put("紫霞仙子", new User("紫霞仙子", "123456"));
        validUsers.put("菩提老祖", new User("菩提老祖", "123456"));

    }

    //  验证用户是否有效
    private boolean checkUser(String uerId, String passwd) {

        User user = validUsers.get(uerId);
        //  过关斩将法
        if (user == null) { //  说明 userId没有存在 validUsers 的key 中
            return false;
        }
        if (!(passwd.equals(user.getPasswd()))){   //  userId 正确，但是密码错误
            return false;
        }
        return true;
    }

    public QQServer() {
        //  注意，端口可以卸载配置文件中
        System.out.println("服务端在9999端口监听...");
        try {
            serverSocket = new ServerSocket(9999);

            while (true) {  //  当和某个客户端建立链接后，会继续监听，因此while循环
                Socket socket = serverSocket.accept();  //  如果没有客户端连接，就会阻塞在这里
                //  得到 socket 关联的对象输入流
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                User user = (User)ois.readObject(); //  我们事先知道，客户端发过来的是 User 对象 ---> 向下转型

                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());

                //  创建一个Message 对象，准备回复给客户端 [不管成功与否，都需要给客户端回复一个 Message]
                Message message = new Message();

                //  验证
                if (checkUser(user.getUserId(), user.getPasswd())){
                    message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);
                    //  将 Message 对象回复
                    oos.writeObject(message);
                    //  创建一个线程，和客户端保持通信，同时该线程需要持有 Socket 对象
                    ServerConnectClientThread serverConnectClientThread = new ServerConnectClientThread(socket, user.getUserId());
                    //  启动线程
                    serverConnectClientThread.start();
                    //  把该线程对象，放入到一个集合中，进行管理
                    ManageServerConnectClientThread.addServerConnectClientThread(user.getUserId(), serverConnectClientThread);

                }else{  //  登录失败
                    System.out.println("用户 id=" + user.getUserId() + "pwd=" + user.getPasswd() + "验证失败");
                    message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);
                    oos.writeObject(message);
                    //  关闭socket
                    socket.close();
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //  如果服务器退出了 while，说明服务器不再监听，因此关闭 ServerSocket
            try {
                serverSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



开始测试：

客户端中，View就相当于界面，在界面中可以调用我们的方法！！！

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301354164.png)

客户端的线程会一直卡在这里，直到客户端，输入：1 显示在线用户列表后，流程又重新打通了！！！

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301357456.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301400752.png)

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301400292.png)

#### 3. 无异常退出系统

按下 9 的时候，调用方法，停止客户端线程，同时服务端线程也停止

- 客户端同时给服务器发送 String MESSAGE_CLIENT_EXIT = "6";
- 服务器收到后，停止对应线程



##### 异常原因

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301602899.png)

main() ---> new QQView().mainMenu ---> 输入1. 调用 checkUser() 方法

满足连接登录成功条件之后，开启线程 clientConnectServerThread.start()

```java
//  根据 userId 和 pwd 到服务器验证该用户是否合法
    public boolean checkUser(String userId, String pwd) {
        boolean b = false;  //  变量 b 判断 checkUser 是否通过
 
 
        //  设置 user对象属性
        user.setUserId(userId);
        user.setPasswd(pwd);
        //  连接到服务端，发送 user对象
        try {
            socket = new Socket("192.168.8.228", 9999);
            //  得到 ObjectOutputStream 对象
            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
            oos.writeObject(user);  // 发送 user 对象
 
            //  读取从服务器回复的 Message 对象
            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
            Message ms = (Message) ois.readObject();  //  向下转型
 
            if ((MessageType.MESSAGE_LOGIN_SUCCEED).equals(ms.getMesType())){   //  登录成功了
 
                b = true;
                //  创建一个和服务器端保持通信的线程  ---> 创建一个类 ClientConnectServerThread
                ClientConnectServerThread clientConnectServerThread = new ClientConnectServerThread(socket);
                //  启动客户端的线程
                clientConnectServerThread.start();
 
                //  这里为了后面客户端的扩展，我们将线程放入到集合管理，再创建一个类 ManageClientConnectServerThread
                ManageClientConnectServerThread.addClientConnectServerThread(userId, clientConnectServerThread);
 
            } else {
                //  如果登录失败，就不能启动和服务器通信的线程，要关闭 Socket
                socket.close();
            }
 
        } catch (Exception e) {
            e.printStackTrace();
        }
 
        return b;
    }
```

由于这个线程 【clientConnectServerThread.start()】 没有结束，就会导致进程没有结束

##### 解决方法

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301619576.png)

###### 客户端

1. 在 main 线程中，调用方法，给服务器端发送一个退出系统的 message
2. 调用 System.exit(0) // 正常退出

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301613395.png)

```java
//	正常退出，即：进程直接挂了
System.exit(0);
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301616875.png)

<font color="red"> 进程 </font>挂了，那么下面的线程也就全都挂了

最后，在管理线程的类中也要把对应的线程删掉

=======================================================================================================

###### 客户端实现

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301624341.png)

现在因为只有一个线程，后序还可以考虑单个客户端多个线程的场景（比如：视频通话 + QQ聊天）

```java
//  编写方法，退出客户端，并给服务端发送一个退出系统得 message 对象
//	现在就只是仅仅有一个 登录线程，即：客户端只有一个 socket
public void logout() {
    Message message = new Message();
    message.setMesType(MessageType.MESSAGE_CLIENT_EXIT);
    message.setSender(user.getUserId());    //  一定要指定我是哪个 客户端 id

    //  发送 message
    try {
        //  将来如果有多个 socket 时，按照如下方法来写
        //  不然的话，你这个退出的消息就不知道怎么发了
        //  从管理线程得 集合（ManageClientConnectServerThread）里面获取一个线程（根据userId），再拿到对应得 socket，然后再去获得它的一个输出流对象
        ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(user.getUserId()).getSocket().getOutputStream());
        //            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
        oos.writeObject(message);
        System.out.println(user.getUserId() + "退出系统 ");
        System.exit(0); //  结束进程
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301626352.png)

###### 服务端

1. 服务器端和某个客户端通信的线程如果接收到了一个退出系统的 message后
2. 把这个线程持有 socket 关闭
3. 退出线程

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301633869.png)

###### 服务端实现

服务端相对简单一些了

服务端线程一直处于 Run（），一直等待你客户端发过来的消息

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301637690.png)

```java
//  增加一个方法，从集合中，移除某个线程对象
public static void removeServerConnectionThread(String userId) {
    hm.remove(userId);
}
```

测试：

![image-20221130183222912](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301832771.png)

#### 4. 私聊

##### 思路分析【服务器做一个转发】

![img](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301835740.png)

##### 客户端

```java
case "3":
    System.out.println("请输入想要聊天的用户号（在线）：");
    String receiverId = Utility.readString(50);
    System.out.println("请输入想输入的话");
    String content = Utility.readString(100);
    //  编写一个方法，将消息发送给服务器
    privateGroupChat.sendMessageToOne(content, userID, receiverId);
    System.out.println("私聊消息");
	break;
```

###### Private_Group_Chat（提供和消息相关的服务方法）

```java
/**
 * 该类 提供和消息相关的服务方法
 */
public class Private_Group_Chat {
    /**
     * @param content 内容
     * @param senderId 发送者 id
     * @param receiverId 接收者 id
     */
    public void sendMessageToOne(String content, String senderId, String receiverId){
        //  构建 message
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_COMM_MES);   //   普通的聊天消息类型
        message.setSender(senderId);
        message.setReceiver(receiverId);
        message.setContent(content);
        message.setSendTime(new java.util.Date().toString());

        System.out.println(senderId + " 对 " + receiverId + " 说 " + content);

        //  发送给服务端
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### 服务端

```java
else if (MessageType.MESSAGE_COMM_MES.equals(message.getMesType())){
    //  根据 message 获取 receiverId，然后再得到对应的线程
    ServerConnectClientThread serverConnectClientThread = ManageServerConnectClientThread.getServerConnectClientThread(message.getReceiver());
    //  得到对应 socket 的对象输出流，将 message 对象转发给指定的客户端
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
    oos.writeObject(message);   // 转发，对方用户不在线的话，就可以保存在数据库中，做成离线留言
}
```

##### 客户端

```java
在 run() 方法中左 if 判定，然后输出喽
/**
 * @Author: Ronnie LEE
 * @Date: 2022/9/20 - 09 - 20 - 17:03
 * @Description: QQClient.service
 * @version: 1.0
 */
public class ClientConnectServerThread extends Thread{
    //  该线程需要持有 Socket
    private Socket socket;

    //  构造器可以接收一个 Socket 对象
    public ClientConnectServerThread(Socket socket) {
        this.socket = socket;
    }

    //  为了更方便地得到 Socket
    public Socket getSocket() {
        return socket;
    }


    @Override
    public void run() {
        //  因为 Thread 需要在后台和服务进行通信，因此使用 while循环
        while (true) {
            System.out.println("客户端线程，等待读取从服务器发来的消息");
            try {
                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream()); //  通过 socket 获取 流对象
                Message ms = (Message) ois.readObject();    //  如果服务器没有发送 Message 对象，线程会阻塞在这里

                //  注意，后面我们需要去使用 message
                //  判断这个 message 类型，然后做相应的业务处理
                //  如果读取到的是 服务器返回的在线用户列表
                if (MessageType.MESSAGE_RET_ONLINE_USERS.equals(ms.getMesType())){
                    //  取出在线用户列表信息，并打印
                    String[] onLineUsers = ms.getContent().split(" ");
                    System.out.println("\n==========当前在线用户列表=========");
                    for (int i = 0; i < onLineUsers.length; i++) {
                        System.out.println("用户：" + onLineUsers[i]);
                    }
                } else if ((MessageType.MESSAGE_COMM_MES.equals(ms.getMesType()))){ //  如果接收到的是 普通聊天消息
                    //  把从服务器端转发的消息，显示到控制台即可
                    System.out.println("\n" + ms.getSender() + " 对 " + ms.getReceiver() + " 说： " + ms.getContent());
                } else {
                    System.out.println("是其它类型的message，暂时不处理");
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

测试：

![image-20221130191852988](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211301918135.png)

#### 5. 群聊

取出排除自己的所有线程

##### 客户端

```java
case "2":
    System.out.println("请输入想对大家说的话：");
    String s = Utility.readString(100);
    //  调用一个方法，将消息封装成 message 对象，发送给服务端
    privateGroupChat.sendMessageToALL(s, userID);
    break;
```

```java
package QQClient.service;

import QQClient.qqcommon.Message;
import QQClient.qqcommon.MessageType;

import java.io.IOException;
import java.io.ObjectOutputStream;

/**
 * @Author: Ronnie LEE
 * @Date: 2022/10/24 - 10 - 24 - 16:39
 * @Description: QQClient.service
 * @version: 1.0
 * 该类 提供和消息相关的服务方法
 */

    /**
     * @param content   内容
     * @param senderId  发送者
     */
    public void sendMessageToALL(String content, String senderId){
        //  构建 message 对象
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_TO_ALL_MES);   //    群发消息这种类型
        message.setSender(senderId);
        message.setContent(content);
        message.setSendTime(new java.util.Date().toString());

        System.out.println(senderId + " 对大家说 " + content);

        //  发送给服务端
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### 服务器

```java
else if (MessageType.MESSAGE_TO_ALL_MES.equals(message.getMesType())){
    //    需要遍历 管理线程的集合，把所有线程的 socket 得到，然后把 message 进行转发即可
    HashMap<String, ServerConnectClientThread> hm = ManageServerConnectClientThread.getHm();
    Iterator<String> iterator = hm.keySet().iterator();
    while (iterator.hasNext()) {
        //  取出在线用户 Id
        String onLineUserId = iterator.next().toString();
        if (!onLineUserId.equals(message.getSender())){ //  排除自己
            //  进行转发 message
            ObjectOutputStream oos = new ObjectOutputStream(hm.get(onLineUserId).getSocket().getOutputStream());
            oos.writeObject(message);
        }
    }
}
```

##### 客户端

```java
else if ((MessageType.MESSAGE_TO_ALL_MES.equals(ms.getMesType()))){
    //  收到来自 ××× 的群发消息
    System.out.println("\n" +"收到来自 " + ms.getSender() + " 的群发消息" + "\n" + ms.getContent());
}
```

#### 6. 发送文件 【Message ---> 文件字节数组】

##### 思路分析

![image-20221130235706057](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202211302357939.png)

##### 客户端

扩展 MessageType

```java
String MESSAGE_FILE_MES = "8";  //  文件消息（发送文件）
```

扩展 Message

```java
//  进行扩展 和文件相关的成员
private byte[] fileBytes;

//  进行扩展 和文件相关的成员
private byte[] fileBytes;
private int fileLen = 0;
private String dest;    //  将文件传输到哪里
private String src;     //  源文件路径
```

新建 FileClientService

```java
/**
 * 该类 / 对象完成 文件传输服务
 */
public class FileClientService {

    public void sendFileToOne(String src, String dest, String senderId, String receiverId){
        //  读取 src 文件 ---> message 对象
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_FILE_MES);
        message.setSender(senderId);
        message.setReceiver(receiverId);
        message.setSrc(src);
        message.setDest(dest);

        //  需要将文件读取
        FileInputStream fileInputStream = null;
        byte[] fileBytes = new byte[(int)new File(src).length()];
        try {
            fileInputStream = new FileInputStream(src);
            fileInputStream.read(fileBytes);    //  将 src 文件读入到程序的字节数组
            //  将文件对应的字节数组设置 message
            message.setFileBytes(fileBytes);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //  关闭流
            if (fileInputStream != null){
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        //  提示信息
        System.out.println("\n" + senderId + " 给 " + receiverId + " 发送文件 " + src + " 到对方目录 " + dest);

        //  发送 [拿到 socket 输出流]
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

```



##### 服务端

同步更新扩展

在线程中增加业务逻辑

```java
else if (MessageType.MESSAGE_FILE_MES.equals(message.getMesType())){
    //  根据 message 获取 receiverId，然后再得到对应的线程
    ServerConnectClientThread serverConnectClientThread = ManageServerConnectClientThread.getServerConnectClientThread(message.getReceiver());
    ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
    oos.writeObject(message);
}
```

##### 客户端

读取 message信息，读取到 byte[] file 数组中，写入到磁盘中

在 ClientConnectServerThread 中增加业务逻辑

```java
else if (MessageType.MESSAGE_FILE_MES.equals(ms.getMesType())){
    System.out.println("\n" + ms.getSender() + " 给 " + ms.getReceiver() + " 发送文件 " +
                       ms.getSrc() + " 到我的电脑的" + ms.getDest());
    //  取出 ms 的文件字节数组，通过文件输出流写出到磁盘
    byte[] fileBytes = ms.getFileBytes();
    FileOutputStream fileOutputStream = new FileOutputStream(ms.getDest());
    fileOutputStream.write(fileBytes);
    fileOutputStream.flush();
    fileOutputStream.close();
    System.out.println("\n 保存文件成功~");
}
```

更新菜单 QQView.java

```java
case "4":
    System.out.println("你想把文件发送给谁：（在线）");
    String receiverId1 = Utility.readString(50);
    System.out.println("请输入要发送文件的路径：（形式：d:/xx.jpg）");
    String src = Utility.readString(100);
    System.out.println("请输入你要发送到对方的路径");
    String dest = Utility.readString(100);
    fileClientService.sendFileToOne(src, dest, userID, receiverId1);
    break;
```

![image-20221201010820991](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212010108183.png)

#### 7. 服务器推送新闻 【服务器端新增一个推送信息的线程】

##### 思路

1. 本质就是群发消息
2. 在服务器端启动一条独立的线程，专门负责推送新闻

![image-20221201113517072](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212011135720.png)

##### 服务器

新建一个线程

```java
/**
 * 输入服务器要推送的消息
 * message 复用消息类型 [MessageType.MESSAGE_TO_ALL_MES]
 */
public class SendNewsToAllService implements Runnable {

    @Override
    public void run() {
        while (true){
            System.out.println("请输入服务器要推送的消息： [输入 exit 推出推送服务]");
            String news = Utility.readString(100);
            if ("exit".equals(news)){
                break;
            }
            //  构建一个群发消息
            Message message1 = new Message();
            message1.setSender("服务器");
            message1.setContent(news);
            message1.setSendTime(new Date().toString());
            message1.setMesType(MessageType.MESSAGE_TO_ALL_MES);
            System.out.println("服务器推送消息给所有人说：" + news);

            //  拿到所有与服务器通讯的线程
            HashMap<String, ServerConnectClientThread> hm = ManageServerConnectClientThread.getHm();

            if (hm.isEmpty()){
                System.out.println("没有用户在线，推送失败！！！");
            }

            for (String onLineUserId : hm.keySet()) {
                ServerConnectClientThread serverConnectClientThread = hm.get(onLineUserId);
                Socket socket = serverConnectClientThread.getSocket();
                try {
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    oos.writeObject(message1);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

在 QQServer() 中调用线程

```java
public QQServer() {
    //  注意，端口可以卸载配置文件中
    System.out.println("服务端在9999端口监听...");
    try {
        serverSocket = new ServerSocket(9999);
        //  启动推送新闻的线程
        new Thread(new SendNewsToAllService()).start();

        while (true) {  //  当和某个客户端建立链接后，会继续监听，因此while循环
```

#### 8. 功能扩展

##### 离线留言

https://blog.csdn.net/weixin_44142151/article/details/124188691

![image-20221201161033582](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212011610180.png)

服务器端再做一个集合 ConcurrentHashMap，存放 <receiverId，ArrayList<message>>【ArrayList 可以放多个 message】

- 当客户端上线之后，去 ConcurrentHashMap 中去查看是否有自己的离线消息

- 如果有的话，服务器就转发给它

- 并将信息从集合中删除掉。

  

在 ManageServerConnectClientThread  中创建实例和相关方法

```java
//  返回 db 集合
public static ConcurrentHashMap<String, ArrayList<Message>> getDb() {
    return db;
}

//  增加一个方法，从集合中，移除某个线程对象
public static void removeServerConnectionThread(String userId) {
    hm.remove(userId);
}

//  添加 message 对象到 db 集合
public static void addArrayListMessage(String usrId, ArrayList<Message> messages){
    db.put(usrId, messages);
}

//  根据 receiverId 获得 相应的 ArrayList<Message> 对象
public static ArrayList<Message> getArrayList(String receiverId){
    return db.get(receiverId);
}

//  增加一个方法，从db集合中，删除某个 message 对象
public static void removeMessage(String receiverId){
    db.remove(receiverId);
}
```

###### db【存储留言信息】

```java
private static ConcurrentHashMap<String, ArrayList<Message>> db = new ConcurrentHashMap<>();
```

![image-20221201190419272](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212011904684.png)

###### db增加

```java
else if (MessageType.MESSAGE_COMM_MES.equals(message.getMesType())){
                    //  根据 message 获取 receiverId，然后再得到对应的线程
                    String receiver = message.getReceiver();
                    if (QQServer.getValidUsers().containsKey(receiver)) {   //  输入的是已注册用户
                        if (!ManageServerConnectClientThread.getHm().containsKey(receiver)) {  //  接收者离线
                            ConcurrentHashMap<String, ArrayList<Message>> db = ManageServerConnectClientThread.getDb();
                            if (db.get(receiver) == null) {  //  如果之前没有留言信息
                                System.out.println("接收方离线，将消息存到 db");
                                ArrayList<Message> messages = new ArrayList<>();
                                messages.add(message);
                                db.put(receiver, messages);
                            } else { //  之前已经有消息了
                                System.out.println("接收方离线，将消息存到 db(之前已有记录)");
                                db.get(receiver).add(message);  //  就只做 添加操作了
                            }
                        } else { //  接收者在线
                            ServerConnectClientThread serverConnectClientThread = ManageServerConnectClientThread.getServerConnectClientThread(message.getReceiver());
                            //  得到对应 socket 的对象输出流，将 message 对象转发给指定的客户端
                            ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
                            oos.writeObject(message);   // 转发，对方用户不在线的话，就可以保存在数据库中，做成离线留言
                        }
                    }else {
                        //  收入的是未注册用户
                        Message message_unregister = new Message();
                        message_unregister.setReceiver(message.getReceiver());
                        message_unregister.setMesType(MessageType.MESSAGE_UNREGISTER);
                        //  因为接收者不存在，所以给客户端返回一个目的用户未注册的 Message
                        ServerConnectClientThread serverConnectClientThread = ManageServerConnectClientThread.getServerConnectClientThread(message.getSender());
                        ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
                        oos.writeObject(message_unregister);
                    }
                }
```



###### db清空 【线程刚start() 时候进行判断】

QQServer 中判断

- 用户登录时，客户端会发来一个 User 对象

- 服务器取出 User 对象的 userId

  ```java
  user.getUserId()
  ```

- 然后再 db 中判断是否有该 user 的离线消息

- 如果有的话，新建一个 message对象，将 ArrayList <Message> 回送给客户端

- 最后 db 清除该用户的信息

```java
if (db.containsKey(user.getUserId())){   //  看下是否有你的离线消息
    //  注意：第一次登录的时候，服务器发送的 是 User 对象，要根据 usrId 来判定
    System.out.println("离线的用户" + user.getUserId() + "上线了");
    ObjectOutputStream oos_db = new ObjectOutputStream(ManageServerConnectClientThread.getServerConnectClientThread(user.getUserId()).getSocket().getOutputStream());
    //  取出 ArrayList 中的 Message 对象
    ArrayList<Message> messages = db.get(user.getUserId());
    Message message_db = new Message();
    message_db.setMesType(MessageType.MESSAGE_COMM_MES);
    message_db.setArrayList(messages);
    oos_db.writeObject(message);
    //  清空 db1
    db.remove(user.getUserId());
}
```



问题2：invalid stream header：7374007E

![image-20221201192045554](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212011920646.png)

问题原因：

- OjbectOutputStream

  ```java
  //	ObjectOutputStream每次new的时候都会调用writeStreamHeader()方法写入4个字节的StreamHeader
  public ObjectOutputStream(OutputStream var1) throws IOException {
      this.verifySubclass();
      this.bout = new ObjectOutputStream.BlockDataOutputStream(var1);
      this.handles = new ObjectOutputStream.HandleTable(10, 3.0F);
      this.subs = new ObjectOutputStream.ReplaceTable(10, 3.0F);
      this.enableOverride = false;
      this.writeStreamHeader();	//	写入了4个字节的 StreamHeader
      this.bout.setBlockDataMode(true);
      if (extendedDebugInfo) {
          this.debugInfoStack = new ObjectOutputStream.DebugTraceInfoStack();
      } else {
          this.debugInfoStack = null;
      }
  
  }
  ```

  ```java
  protected void writeStreamHeader() throws IOException {
      this.bout.writeShort(-21267);	//	魔数
      this.bout.writeShort(5);	    //  版本号
      //	2个都是 short 类型，占 4 个字节
  }
  ```

  

- ObjectInputStream 

  ```java
  //	ObjectInputStream每次new的时候都会调用readStreamHeader()方法读入4个字节的StreamHeader，标记这是对象处理流。
  public ObjectInputStream(InputStream in) throws IOException {
      verifySubclass();
      bin = new BlockDataInputStream(in);
      handles = new HandleTable(10);
      vlist = new ValidationList();
      serialFilter = ObjectInputFilter.Config.getSerialFilter();
      enableOverride = false;
      readStreamHeader();	//	读入 4个字节的 StreamHeader
      bin.setBlockDataMode(true);
  }
  ```

  ```java
  protected void readStreamHeader()
      throws IOException, StreamCorruptedException
  {
      short s0 = bin.readShort();
      short s1 = bin.readShort();
      if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
          throw new StreamCorruptedException(
              String.format("invalid stream header: %04X%04X", s0, s1));	//	报错原因
      }
  }
  ```

  ```java
  public short readShort() throws IOException {
      if (!blkmode) {
          pos = 0;
          in.readFully(buf, 0, 2);
      } else if (end - pos < 2) {
          return din.readShort();
      }
      short v = Bits.getShort(buf, pos);
      pos += 2;
      return v;
  }
  ```

  ![image-20221201200445544](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212012004635.png)

所以会造成：第一个对象是正常接收，从第二个对象开始就报错了

方案一、

这种方式执行是完全Ok的， 但是想用不同的ObjectInputStream对象（）的readObject方法依次取出所有的对象，这是不行的，每次只会取第一个对象。（退一万步讲述，就算可以，耗内存的同时又代码冗长）

方案二、

服务端直接把整个Arraylist放到一个new Message（）对象中，客户端收到整个ArrayList再打开一个个Message执行相应工作。

###### 客户端

```java
else if ((MessageType.MESSAGE_COMM_MES.equals(ms.getMesType()))){ //  如果接收到的是 普通聊天消息
    //  把从服务器端转发的消息，显示到控制台即可
    if (ms.getArrayList() != null){	//	离线留言
        System.out.println("收到离线留言如下：");
        ArrayList<Message> arrayList = ms.getArrayList();
        for (Message message : arrayList) {
            System.out.println("收到来自 " + message.getSender() + "的离线留言");
            System.out.println(message.getContent());
            System.out.println("===============");
        }
    }else {	//	在线沟通
        System.out.println("\n" + ms.getSender() + " 对 " + ms.getReceiver() + " 说： " + ms.getContent());
    }
```



##### 离线发文件

##### 思路

整体思路和离线留言是一样的

我们之前已经为 message 对象新增了对象来封装 字节流

```java
//  进行扩展 和文件相关的成员
private byte[] fileBytes;
private int fileLen = 0;
private String dest;    //  将文件传输到哪里
private String src;     //  源文件路径

//	和相应的get() 和 set() 方法
public byte[] getFileBytes() {
    return fileBytes;
}

message.getFileBytes()：返回 message 对象携带的 字节流（文件）
```

当用户输入：4 ---> 调用 sendFileToOne(src, dest, uerId, receiverId1) 方法

```java
case "4":
System.out.println("你想把文件发送给谁：（在线）");
String receiverId1 = Utility.readString(50);
System.out.println("请输入要发送文件的路径：（形式：d:/xx.jpg）");
String src = Utility.readString(100);
System.out.println("请输入你要发送到对方的路径");
String dest = Utility.readString(100);
fileClientService.sendFileToOne(src, dest, userID, receiverId1);
break;
```

```java
/**
 * 该类 / 对象完成 文件传输服务
 */
public class FileClientService {

    public void sendFileToOne(String src, String dest, String senderId, String receiverId){
        //  读取 src 文件 ---> message 对象
        Message message = new Message();
        message.setMesType(MessageType.MESSAGE_FILE_MES);
        message.setSender(senderId);
        message.setReceiver(receiverId);
        message.setSrc(src);
        message.setDest(dest);

        //  需要将文件读取
        FileInputStream fileInputStream = null;
        byte[] fileBytes = new byte[(int)new File(src).length()];
        try {
            fileInputStream = new FileInputStream(src);
            fileInputStream.read(fileBytes);    //  将 src 文件读入到程序的字节数组
            //  将文件对应的字节数组设置 message
            message.setFileBytes(fileBytes);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //  关闭流
            if (fileInputStream != null){
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        //  提示信息
        System.out.println("\n" + senderId + " 给 " + receiverId + " 发送文件 " + src + " 到对方目录 " + dest);

        //  发送 [拿到 socket 输出流]
        try {
            ObjectOutputStream oos = new ObjectOutputStream(ManageClientConnectServerThread.getClientConnectServerThread(senderId).getSocket().getOutputStream());
            oos.writeObject(message);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

将封装好的 message 发送给 服务器

##### 服务器

ManageServerConnectClientThread中，新增 file_offLine 集合存储离线文件

```java
private static ConcurrentHashMap<String, ArrayList<Message>> file_offLine_db = new ConcurrentHashMap<>();

// 并添加相关方法
//  返回 file_offLine 集合
public static ConcurrentHashMap<String, ArrayList<Message>> getFile_offLine_db(){
    return file_offLine_db;
}

//  增加一个方法，将 byte[] 字节数组添加到 file_offLine集合中：
public static void addOffLineFile(String userId, ArrayList<Message> messages){
    file_offLine_db.put(userId, messages);
}

//  根据 UserId receiverId 获得 相应的 ArrayList<Message> 对象
public static ArrayList<Message> getFileBytes(String receiverId){
    return file_offLine_db.get(receiverId);
}

//  增加一个方法，从 file_offLine 中删除某个 ArrayList<Message> 对象
public static void removeFileBytes(String receiverId){
    file_offLine_db.remove(receiverId);
}
```

同时再给 message 增加一个属性：

```java
private ArrayList<Message> file_offLine_db;   //  离线文件组
//	响应 getter 和 setter 方法
public ArrayList<Message> getFile_offLine_db() {
    return file_offLine_db;
}

public void setFile_offLine_db(ArrayList<Message> file_offLine_db) {
    this.file_offLine_db = file_offLine_db;
}
```

###### file_offLine_db 增加

```java
else if (MessageType.MESSAGE_FILE_MES.equals(message.getMesType())){
    //  根据 message 获取 receiverId，然后再得到对应的线程
    //  如果接收者离线
    String receiver = message.getReceiver();
    //  根据 message 获取 receiverId，然后再得到对应的线程
    //  如果接收者离线
    if (!ManageServerConnectClientThread.getHm().containsKey(receiver)){
        ConcurrentHashMap<String, ArrayList<Message>> file_offLine_db = ManageServerConnectClientThread.getFile_offLine_db();
        if (file_offLine_db.get(receiver) == null) {
            System.out.println("接收方离线，将信息存储到 file_offLine_db");
            ArrayList<Message> messages = new ArrayList<>();
            messages.add(message);
            file_offLine_db.put(receiver, messages);
        } else { //  之前该用户已有离线文件了
            System.out.println("接收方离线，将信息保存到 file_offLine_db（之前已有记录）");
            file_offLine_db.get(receiver).add(message); //  只做添加操作
        }
    }else { //  接收方在线
        ServerConnectClientThread serverConnectClientThread = ManageServerConnectClientThread.getServerConnectClientThread(message.getReceiver());
        ObjectOutputStream oos = new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());
        oos.writeObject(message);
    }
}
```

###### file_offLine_db 清空

```java
//  处理离线文件
//  登录时，客户端发送一个 user 对象过来
ConcurrentHashMap<String, ArrayList<Message>> file_offLine_db = ManageServerConnectClientThread.getFile_offLine_db();
//	离线文件库中有你的消息，优先处理，转发文件到客户端
if (file_offLine_db.containsKey(user.getUserId())){
    System.out.println("离线的用户" + user.getUserId() + "上线了");
    System.out.println("准备转送离线文件");
    ObjectOutputStream oos_fileOffLine = new ObjectOutputStream(ManageServerConnectClientThread.getServerConnectClientThread(user.getUserId()).getSocket().getOutputStream());
    //  取出 ArrayList<Message> messages 放入 message 的属性 private ArrayList<Message> file_offLine_db 中
    //	客户端通过 getFile_offLine_db() 取出后，进行进一步处理
    ArrayList<Message> messages = file_offLine_db.get(user.getUserId());

    Message message_offLineFiles = new Message();
    message_offLineFiles.setMesType(MessageType.MESSAGE_FILE_MES);
    message_offLineFiles.setFile_offLine_db(messages);	//	设置 message 的标记
    oos_fileOffLine.writeObject(message_offLineFiles);
    //  清空 file_offLine_db
    file_offLine_db.remove(user.getUserId());
}
```

##### 客户端

```java
else if (MessageType.MESSAGE_FILE_MES.equals(ms.getMesType())){
    if(ms.getFile_offLine_db()!=null) {   //  离线文件处理
        System.out.println("收到离线文件");
        ArrayList<Message> file_offLine_db = ms.getFile_offLine_db();
        for (Message message : file_offLine_db) {
            System.out.println("\n收到来自" + message.getSender() + " 给 " + message.getReceiver() + " 发送文件 "+
                               message.getSrc() + "到我的电脑的" + message.getDest());

            //  取出字节数组，通过文件输出流写出到磁盘
            byte[] fileBytes = message.getFileBytes();
            FileOutputStream fileOutputStream = new FileOutputStream(message.getDest());
            fileOutputStream.write(fileBytes);
            fileOutputStream.flush();
            fileOutputStream.close();
            System.out.println("\n 保存文件成功~");
        }
    }else {
        System.out.println("\n" + ms.getSender() + " 给 " + ms.getReceiver() + " 发送文件 " +
                           ms.getSrc() + " 到我的电脑的" + ms.getDest());
        //  取出 ms 的文件字节数组，通过文件输出流写出到磁盘
        byte[] fileBytes = ms.getFileBytes();
        FileOutputStream fileOutputStream = new FileOutputStream(ms.getDest());
        fileOutputStream.write(fileBytes);
        fileOutputStream.flush();
        fileOutputStream.close();
        System.out.println("\n 保存文件成功~");
    }
}
```

测试

![image-20221202155034336](https://cdn.jsdelivr.net/gh/RonnieLee24/PicGo_Pictures@master/imgs/DB/202212021550990.png)

##### 

## 8. 内容梳理





